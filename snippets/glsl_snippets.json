{

    // Built-In Language Variables
    "in int gl_VertexID": {
        "prefix": "gl_VertexID",
        "body": "gl_VertexID",
        "description": "TODO"
    },
    "in int gl_InstanceID": {
        "prefix": "gl_InstanceID",
        "body": "gl_InstanceID",
        "description": "TODO"
    },
    "in int gl_VertexIndex": {
        "prefix": "gl_VertexIndex",
        "body": "gl_VertexIndex",
        "description": "TODO"
    },
    "in int gl_InstanceIndex": {
        "prefix": "gl_InstanceIndex",
        "body": "gl_InstanceIndex",
        "description": "TODO"
    },
    "in int gl_DrawID": {
        "prefix": "gl_DrawID",
        "body": "gl_DrawID",
        "description": "TODO"
    },
    "in int gl_BaseVertex": {
        "prefix": "gl_BaseVertex",
        "body": "gl_BaseVertex",
        "description": "TODO"
    },
    "in int gl_BaseInstance": {
        "prefix": "gl_BaseInstance",
        "body": "gl_BaseInstance",
        "description": "TODO"
    },
    "out gl_PerVertex {vec4 gl_Position; float gl_PointSize; float gl_ClipDistance[]; float gl_CullDistance[];}": {
        "prefix": "gl_PerVertex",
        "body": "gl_PerVertex",
        "description": "TODO"
    },
    "t": {
        "prefix": "t",
        "body": "t",
        "description": "TODO"
    },

    // Transparent Types
    "type-void": {
        "prefix": "void",
        "body": "void",
        "description": "for functions that do not return a value"
    },
    "type-bool": {
        "prefix": "bool",
        "body": "bool",
        "description": "a conditional type, taking on values of true or false"
    },
    "type-int": {
        "prefix": "int",
        "body": "int",
        "description": "a signed integer"
    },
    "type-uint": {
        "prefix": "uint",
        "body": "uint",
        "description": "an unsigned integer"
    },
    "type-float": {
        "prefix": "float",
        "body": "float",
        "description": "a single-precision floating-point scalar"
    },
    "type-double": {
        "prefix": "double",
        "body": "double",
        "description": "a double-precision floating-point scalar"
    },
    "type-vec2": {
        "prefix": "vec2",
        "body": "vec2",
        "description": "a two-component single-precision floating-point vector"
    },
    "type-vec3": {
        "prefix": "vec3",
        "body": "vec3",
        "description": "a three-component single-precision floating-point vector"
    },
    "type-vec4": {
        "prefix": "vec4",
        "body": "vec4",
        "description": "a four-component single-precision floating-point vector"
    },
    "type-dvec2": {
        "prefix": "dvec2",
        "body": "dvec2",
        "description": "a two-component double-precision floating-point vector"
    },
    "type-dvec3": {
        "prefix": "dvec3",
        "body": "dvec3",
        "description": "a three-component double-precision floating-point vector"
    },
    "type-dvec4": {
        "prefix": "dvec4",
        "body": "dvec4",
        "description": "a four-component double-precision floating-point vector"
    },
    "type-bvec2": {
        "prefix": "bvec2",
        "body": "bvec2",
        "description": "a two-component Boolean vector"
    },
    "type-bvec3": {
        "prefix": "bvec3",
        "body": "bvec3",
        "description": "a three-component Boolean vector"
    },
    "type-bvec4": {
        "prefix": "bvec4",
        "body": "bvec4",
        "description": "a four-component Boolean vector"
    },
    "type-ivec2": {
        "prefix": "ivec2",
        "body": "ivec2",
        "description": "a two-component signed integer vector"
    },
    "type-ivec3": {
        "prefix": "ivec3",
        "body": "ivec3",
        "description": "a three-component signed integer vector"
    },
    "type-ivec4": {
        "prefix": "ivec4",
        "body": "ivec4",
        "description": "a four-component signed integer vector"
    },
    "type-uvec2": {
        "prefix": "uvec2",
        "body": "uvec2",
        "description": "a two-component unsigned integer vector"
    },
    "type-uvec3": {
        "prefix": "uvec3",
        "body": "uvec3",
        "description": "a three-component unsigned integer vector"
    },
    "type-uvec4": {
        "prefix": "uvec4",
        "body": "uvec4",
        "description": "a four-component unsigned integer vector"
    },
    "type-mat2": {
        "prefix": "mat2",
        "body": "mat2",
        "description": "a 2 × 2 single-precision floating-point matrix"
    },
    "type-mat3": {
        "prefix": "mat3",
        "body": "mat3",
        "description": "a 3 × 3 single-precision floating-point matrix"
    },
    "type-mat4": {
        "prefix": "mat4",
        "body": "mat4",
        "description": "a 4 × 4 single-precision floating-point matrix"
    },
    "type-mat2x2": {
        "prefix": "mat2x2",
        "body": "mat2x2",
        "description": "same as a mat2"
    },
    "type-mat2x3": {
        "prefix": "mat2x3",
        "body": "mat2x3",
        "description": "a single-precision floating-point matrix with 2 columns and 3 rows"
    },
    "type-mat2x4": {
        "prefix": "mat2x4",
        "body": "mat2x4",
        "description": "a single-precision floating-point matrix with 2 columns and 4 rows"
    },
    "type-mat3x2": {
        "prefix": "mat3x2",
        "body": "mat3x2",
        "description": "a single-precision floating-point matrix with 3 columns and 2 rows"
    },
    "type-mat3x3": {
        "prefix": "mat3x3",
        "body": "mat3x3",
        "description": "same as a mat3"
    },
    "type-mat3x4": {
        "prefix": "mat3x4",
        "body": "mat3x4",
        "description": "a single-precision floating-point matrix with 3 columns and 4 rows"
    },
    "type-mat4x2": {
        "prefix": "mat4x2",
        "body": "mat4x2",
        "description": "a single-precision floating-point matrix with 4 columns and 2 rows"
    },
    "type-mat4x3": {
        "prefix": "mat4x3",
        "body": "mat4x3",
        "description": "a single-precision floating-point matrix with 4 columns and 3 rows"
    },
    "type-mat4x4": {
        "prefix": "mat4x4",
        "body": "mat4x4",
        "description": "same as a mat4"
    },
    "type-dmat2": {
        "prefix": "dmat2",
        "body": "dmat2",
        "description": "a 2 × 2 double-precision floating-point matrix"
    },
    "type-dmat3": {
        "prefix": "dmat3",
        "body": "dmat3",
        "description": "a 3 × 3 double-precision floating-point matrix"
    },
    "type-dmat4": {
        "prefix": "dmat4",
        "body": "dmat4",
        "description": "a 4 × 4 double-precision floating-point matrix"
    },
    "type-dmat2x2": {
        "prefix": "dmat2x2",
        "body": "dmat2x2",
        "description": "same as a dmat2"
    },
    "type-dmat2x3": {
        "prefix": "dmat2x3",
        "body": "dmat2x3",
        "description": "a double-precision floating-point matrix with 2 columns and 3 rows"
    },
    "type-dmat2x4": {
        "prefix": "dmat2x4",
        "body": "dmat2x4",
        "description": "a double-precision floating-point matrix with 2 columns and 4 rows"
    },
    "type-dmat3x2": {
        "prefix": "dmat3x2",
        "body": "dmat3x2",
        "description": "a double-precision floating-point matrix with 3 columns and 2 rows"
    },
    "type-dmat3x3": {
        "prefix": "dmat3x3",
        "body": "dmat3x3",
        "description": "same as a dmat3"
    },
    "type-dmat3x4": {
        "prefix": "dmat3x4",
        "body": "dmat3x4",
        "description": "a double-precision floating-point matrix with 3 columns and 4 rows"
    },
    "type-dmat4x2": {
        "prefix": "dmat4x2",
        "body": "dmat4x2",
        "description": "a double-precision floating-point matrix with 4 columns and 2 rows"
    },
    "type-dmat4x3": {
        "prefix": "dmat4x3",
        "body": "dmat4x3",
        "description": "a double-precision floating-point matrix with 4 columns and 3 rows"
    },
    "type-dmat4x4": {
        "prefix": "dmat4x4",
        "body": "dmat4x4",
        "description": "same as a dmat4"
    },
    // Opaque types
    "type-sampler1D": {
        "prefix": "sampler1D",
        "body": "sampler1D",
        "description": "a handle for accessing a 1D texture"
    },
    "type-texture1D": {
        "prefix": "texture1D",
        "body": "texture1D",
        "description": "a handle for accessing a 1D texture"
    },
    "type-image1D": {
        "prefix": "image1D",
        "body": "image1D",
        "description": "a handle for accessing a 1D texture"
    },
    "type-sampler1DShadow": {
        "prefix": "sampler1DShadow",
        "body": "sampler1DShadow",
        "description": "a handle for accessing a 1D depth texture with comparison"
    },
    "type-sampler1DArray": {
        "prefix": "sampler1DArray",
        "body": "sampler1DArray",
        "description": "a handle for accessing a 1D array texture"
    },
    "type-texture1DArray": {
        "prefix": "texture1DArray",
        "body": "texture1DArray",
        "description": "a handle for accessing a 1D array texture"
    },
    "type-image1DArray": {
        "prefix": "image1DArray",
        "body": "image1DArray",
        "description": "a handle for accessing a 1D array texture"
    },
    "type-sampler1DArrayShadow": {
        "prefix": "sampler1DArrayShadow",
        "body": "sampler1DArrayShadow",
        "description": "a handle for accessing a 1D array depth texture with comparison"
    },
    "type-sampler2D": {
        "prefix": "sampler2D",
        "body": "sampler2D",
        "description": "a handle for accessing a 2D texture"
    },
    "type-texture2D": {
        "prefix": "texture2D",
        "body": "texture2D",
        "description": "a handle for accessing a 2D texture"
    },
    "type-image2D": {
        "prefix": "image2D",
        "body": "image2D",
        "description": "a handle for accessing a 2D texture"
    },
    "type-sampler2DShadow": {
        "prefix": "sampler2DShadow",
        "body": "sampler2DShadow",
        "description": "a handle for accessing a 2D depth texture with comparison"
    },
    "type-sampler2DArray": {
        "prefix": "sampler2DArray",
        "body": "sampler2DArray",
        "description": "a handle for accessing a 2D array texture"
    },
    "type-texture2DArray": {
        "prefix": "texture2DArray",
        "body": "texture2DArray",
        "description": "a handle for accessing a 2D array texture"
    },
    "type-image2DArray": {
        "prefix": "image2DArray",
        "body": "image2DArray",
        "description": "a handle for accessing a 2D array texture"
    },
    "type-sampler2DArrayShadow": {
        "prefix": "sampler2DArrayShadow",
        "body": "sampler2DArrayShadow",
        "description": "a handle for accessing a 2D array depth texture with comparison"
    },
    "type-sampler2DMS": {
        "prefix": "sampler2DMS",
        "body": "sampler2DMS",
        "description": "a handle for accessing a 2D multisample texture"
    },
    "type-texture2DMS": {
        "prefix": "texture2DMS",
        "body": "texture2DMS",
        "description": "a handle for accessing a 2D multisample texture"
    },
    "type-image2DMS": {
        "prefix": "image2DMS",
        "body": "image2DMS",
        "description": "a handle for accessing a 2D multisample texture"
    },
    "type-sampler2DMSArray": {
        "prefix": "sampler2DMSArray",
        "body": "sampler2DMSArray",
        "description": "a handle for accessing a 2D multisample array texture"
    },
    "type-texture2DMSArray": {
        "prefix": "texture2DMSArray",
        "body": "texture2DMSArray",
        "description": "a handle for accessing a 2D multisample array texture"
    },
    "type-image2DMSArray": {
        "prefix": "image2DMSArray",
        "body": "image2DMSArray",
        "description": "a handle for accessing a 2D multisample array texture"
    },
    "type-sampler2DRect": {
        "prefix": "sampler2DRect",
        "body": "sampler2DRect",
        "description": "a handle for accessing a rectangle texture"
    },
    "type-texture2DRect": {
        "prefix": "texture2DRect",
        "body": "texture2DRect",
        "description": "a handle for accessing a rectangle texture"
    },
    "type-image2DRect": {
        "prefix": "image2DRect",
        "body": "image2DRect",
        "description": "a handle for accessing a rectangle texture"
    },
    "type-sampler2DRectShadow": {
        "prefix": "sampler2DRectShadow",
        "body": "sampler2DRectShadow",
        "description": "a handle for accessing a rectangle texture with comparison"
    },
    "type-sampler3D": {
        "prefix": "sampler3D",
        "body": "sampler3D",
        "description": "a handle for accessing a 3D texture"
    },
    "type-texture3D": {
        "prefix": "texture3D",
        "body": "texture3D",
        "description": "a handle for accessing a 3D texture"
    },
    "type-image3D": {
        "prefix": "image3D",
        "body": "image3D",
        "description": "a handle for accessing a 3D texture"
    },
    "type-samplerCube": {
        "prefix": "samplerCube",
        "body": "samplerCube",
        "description": "a handle for accessing a cube mapped texture"
    },
    "type-textureCube": {
        "prefix": "textureCube",
        "body": "textureCube",
        "description": "a handle for accessing a cube mapped texture"
    },
    "type-imageCube": {
        "prefix": "imageCube",
        "body": "imageCube",
        "description": "a handle for accessing a cube mapped texture"
    },
    "type-samplerCubeShadow": {
        "prefix": "samplerCubeShadow",
        "body": "samplerCubeShadow",
        "description": "a handle for accessing a cube map depth texture with comparison"
    },
    "type-samplerCubeArray": {
        "prefix": "samplerCubeArray",
        "body": "samplerCubeArray",
        "description": "a handle for accessing a cube map array texture"
    },
    "type-textureCubeArray": {
        "prefix": "textureCubeArray",
        "body": "textureCubeArray",
        "description": "a handle for accessing a cube map array texture"
    },
    "type-imageCubeArray": {
        "prefix": "imageCubeArray",
        "body": "imageCubeArray",
        "description": "a handle for accessing a cube map array texture"
    },
    "type-samplerCubeArrayShadow": {
        "prefix": "samplerCubeArrayShadow",
        "body": "samplerCubeArrayShadow",
        "description": "a handle for accessing a cube map array depth texture with comparison"
    },
    "type-samplerBuffer": {
        "prefix": "samplerBuffer",
        "body": "samplerBuffer",
        "description": "a handle for accessing a buffer texture"
    },
    "type-textureBuffer": {
        "prefix": "textureBuffer",
        "body": "textureBuffer",
        "description": "a handle for accessing a buffer texture"
    },
    "type-imageBuffer": {
        "prefix": "imageBuffer",
        "body": "imageBuffer",
        "description": "a handle for accessing a buffer texture"
    },
    "type-subpassInput": {
        "prefix": "subpassInput",
        "body": "subpassInput",
        "description": "a handle for accessing a floating-point subpass input"
    },
    "type-subpassInputMS": {
        "prefix": "subpassInputMS",
        "body": "subpassInputMS",
        "description": "a handle for accessing a multi-sampled floating-point subpass input"
    },
    // Signed Integer Opaque Types
    "type-isampler1D": {
        "prefix": "isampler1D",
        "body": "isampler1D",
        "description": "a handle for accessing an integer 1D texture"
    },
    "type-itexture1D": {
        "prefix": "itexture1D",
        "body": "itexture1D",
        "description": "a handle for accessing an integer 1D texture"
    },
    "type-iimage1D": {
        "prefix": "iimage1D",
        "body": "iimage1D",
        "description": "a handle for accessing an integer 1D texture"
    },
    "type-isampler1DArray": {
        "prefix": "isampler1DArray",
        "body": "isampler1DArray",
        "description": "a handle for accessing an integer 1D array texture"
    },
    "type-itexture1DArray": {
        "prefix": "itexture1DArray",
        "body": "itexture1DArray",
        "description": "a handle for accessing an integer 1D array texture"
    },
    "type-iimage1DArray": {
        "prefix": "iimage1DArray",
        "body": "iimage1DArray",
        "description": "a handle for accessing an integer 1D array texture"
    },
    "type-isampler2D": {
        "prefix": "isampler2D",
        "body": "isampler2D",
        "description": "a handle for accessing an integer 2D texture"
    },
    "type-itexture2D": {
        "prefix": "itexture2D",
        "body": "itexture2D",
        "description": "a handle for accessing an integer 2D texture"
    },
    "type-iimage2D": {
        "prefix": "iimage2D",
        "body": "iimage2D",
        "description": "a handle for accessing an integer 2D texture"
    },
    "type-isampler2DArray": {
        "prefix": "isampler2DArray",
        "body": "isampler2DArray",
        "description": "a handle for accessing an integer 2D array texture"
    },
    "type-itexture2DArray": {
        "prefix": "itexture2DArray",
        "body": "itexture2DArray",
        "description": "a handle for accessing an integer 2D array texture"
    },
    "type-iimage2DArray": {
        "prefix": "iimage2DArray",
        "body": "iimage2DArray",
        "description": "a handle for accessing an integer 2D array texture"
    },
    "type-isampler2DMS": {
        "prefix": "isampler2DMS",
        "body": "isampler2DMS",
        "description": "a handle for accessing an integer 2D multisample texture"
    },
    "type-itexture2DMS": {
        "prefix": "itexture2DMS",
        "body": "itexture2DMS",
        "description": "a handle for accessing an integer 2D multisample texture"
    },
    "type-iimage2DMS": {
        "prefix": "iimage2DMS",
        "body": "iimage2DMS",
        "description": "a handle for accessing an integer 2D multisample texture"
    },
    "type-isampler2DMSArray": {
        "prefix": "isampler2DMSArray",
        "body": "isampler2DMSArray",
        "description": "a handle for accessing an integer 2D multisample array texture"
    },
    "type-itexture2DMSArray": {
        "prefix": "itexture2DMSArray",
        "body": "itexture2DMSArray",
        "description": "a handle for accessing an integer 2D multisample array texture"
    },
    "type-iimage2DMSArray": {
        "prefix": "iimage2DMSArray",
        "body": "iimage2DMSArray",
        "description": "a handle for accessing an integer 2D multisample array texture"
    },
    "type-isampler2DRect": {
        "prefix": "isampler2DRect",
        "body": "isampler2DRect",
        "description": "a handle for accessing an integer 2D rectangle texture"
    },
    "type-itexture2DRect": {
        "prefix": "itexture2DRect",
        "body": "itexture2DRect",
        "description": "a handle for accessing an integer 2D rectangle texture"
    },
    "type-iimage2DRect": {
        "prefix": "iimage2DRect",
        "body": "iimage2DRect",
        "description": "a handle for accessing an integer 2D rectangle texture"
    },
    "type-isampler3D": {
        "prefix": "isampler3D",
        "body": "isampler3D",
        "description": "a handle for accessing an integer 3D texture"
    },
    "type-itexture3D": {
        "prefix": "itexture3D",
        "body": "itexture3D",
        "description": "a handle for accessing an integer 3D texture"
    },
    "type-iimage3D": {
        "prefix": "iimage3D",
        "body": "iimage3D",
        "description": "a handle for accessing an integer 3D texture"
    },
    "type-isamplerCube": {
        "prefix": "isamplerCube",
        "body": "isamplerCube",
        "description": "a handle for accessing an integer cube mapped texture"
    },
    "type-itextureCube": {
        "prefix": "itextureCube",
        "body": "itextureCube",
        "description": "a handle for accessing an integer cube mapped texture"
    },
    "type-iimageCube": {
        "prefix": "iimageCube",
        "body": "iimageCube",
        "description": "a handle for accessing an integer cube mapped texture"
    },
    "type-isamplerCubeArray": {
        "prefix": "isamplerCubeArray",
        "body": "isamplerCubeArray",
        "description": "a handle for accessing an integer cube map array texture"
    },
    "type-itextureCubeArray": {
        "prefix": "itextureCubeArray",
        "body": "itextureCubeArray",
        "description": "a handle for accessing an integer cube map array texture"
    },
    "type-iimageCubeArray": {
        "prefix": "iimageCubeArray",
        "body": "iimageCubeArray",
        "description": "a handle for accessing an integer cube map array texture"
    },
    "type-isamplerBuffer": {
        "prefix": "isamplerBuffer",
        "body": "isamplerBuffer",
        "description": "a handle for accessing an integer buffer texture"
    },
    "type-itextureBuffer": {
        "prefix": "itextureBuffer",
        "body": "itextureBuffer",
        "description": "a handle for accessing an integer buffer texture"
    },
    "type-iimageBuffer": {
        "prefix": "iimageBuffer",
        "body": "iimageBuffer",
        "description": "a handle for accessing an integer buffer texture"
    },
    "type-isubpassInput": {
        "prefix": "isubpassInput",
        "body": "isubpassInput",
        "description": "a handle for accessing an integer subpass input"
    },
    "type-isubpassInputMS": {
        "prefix": "isubpassInputMS",
        "body": "isubpassInputMS",
        "description": "a handle for accessing a multi-sampled integer subpass input"
    },
    // Unsigned Integer Opaque Types
    "type-usampler1D": {
        "prefix": "usampler1D",
        "body": "usampler1D",
        "description": "a handle for accessing an unsigned integer 1D texture"
    },
    "type-utexture1D": {
        "prefix": "utexture1D",
        "body": "utexture1D",
        "description": "a handle for accessing an unsigned integer 1D texture"
    },
    "type-uimage1D": {
        "prefix": "uimage1D",
        "body": "uimage1D",
        "description": "a handle for accessing an unsigned integer 1D texture"
    },
    "type-usampler1DArray": {
        "prefix": "usampler1DArray",
        "body": "usampler1DArray",
        "description": "a handle for accessing an unsigned integer 1D array texture"
    },
    "type-utexture1DArray": {
        "prefix": "utexture1DArray",
        "body": "utexture1DArray",
        "description": "a handle for accessing an unsigned integer 1D array texture"
    },
    "type-uimage1DArray": {
        "prefix": "uimage1DArray",
        "body": "uimage1DArray",
        "description": "a handle for accessing an unsigned integer 1D array texture"
    },
    "type-usampler2D": {
        "prefix": "usampler2D",
        "body": "usampler2D",
        "description": "a handle for accessing an unsigned integer 2D texture"
    },
    "type-utexture2D": {
        "prefix": "utexture2D",
        "body": "utexture2D",
        "description": "a handle for accessing an unsigned integer 2D texture"
    },
    "type-uimage2D": {
        "prefix": "uimage2D",
        "body": "uimage2D",
        "description": "a handle for accessing an unsigned integer 2D texture"
    },
    "type-usampler2DArray": {
        "prefix": "usampler2DArray",
        "body": "usampler2DArray",
        "description": "a handle for accessing an unsigned integer 2D array texture"
    },
    "type-utexture2DArray": {
        "prefix": "utexture1DArray",
        "body": "utexture1DArray",
        "description": "a handle for accessing an unsigned integer 2D array texture"
    },
    "type-uimage2DArray": {
        "prefix": "uimage2DArray",
        "body": "uimage2DArray",
        "description": "a handle for accessing an unsigned integer 2D array texture"
    },
    "type-usampler2DMS": {
        "prefix": "usampler2DMS",
        "body": "usampler2DMS",
        "description": "a handle for accessing an unsigned integer 2D multisample texture"
    },
    "type-utexture2DMS": {
        "prefix": "utexture2DMS",
        "body": "utexture2DMS",
        "description": "a handle for accessing an unsigned integer 2D multisample texture"
    },
    "type-uimage2DMS": {
        "prefix": "uimage2DMS",
        "body": "uimage2DMS",
        "description": "a handle for accessing an unsigned integer 2D multisample texture"
    },
    "type-usampler2DMSArray": {
        "prefix": "usampler2DMSArray",
        "body": "usampler2DMSArray",
        "description": "a handle for accessing an unsigned integer 2D multisample array texture"
    },
    "type-utexture2DMSArray": {
        "prefix": "utexture2DMSArray",
        "body": "utexture2DMSArray",
        "description": "a handle for accessing an unsigned integer 2D multisample array texture"
    },
    "type-uimage2DMSArray": {
        "prefix": "uimage2DMSArray",
        "body": "uimage2DMSArray",
        "description": "a handle for accessing an unsigned integer 2D multisample array texture"
    },
    "type-usampler2DRect": {
        "prefix": "usampler2DRect",
        "body": "usampler2DRect",
        "description": "a handle for accessing an unsigned integer rectangle texture"
    },
    "type-utexture2DRect": {
        "prefix": "utexture2DRect",
        "body": "utexture2DRect",
        "description": "a handle for accessing an unsigned integer rectangle texture"
    },
    "type-uimage2DRect": {
        "prefix": "uimage2DRect",
        "body": "uimage2DRect",
        "description": "a handle for accessing an unsigned integer rectangle texture"
    },
    "type-usampler3D": {
        "prefix": "usampler3D",
        "body": "usampler3D",
        "description": "a handle for accessing an unsigned integer 3D texture"
    },
    "type-utexture3D": {
        "prefix": "utexture3D",
        "body": "utexture3D",
        "description": "a handle for accessing an unsigned integer 3D texture"
    },
    "type-uimage3D": {
        "prefix": "uimage3D",
        "body": "uimage3D",
        "description": "a handle for accessing an unsigned integer 3D texture"
    },
    "type-usamplerCube": {
        "prefix": "usamplerCube",
        "body": "usamplerCube",
        "description": "a handle for accessing an unsigned integer cube mapped texture"
    },
    "type-utextureCube": {
        "prefix": "utextureCube",
        "body": "utextureCube",
        "description": "a handle for accessing an unsigned integer cube mapped texture"
    },
    "type-uimageCube": {
        "prefix": "uimageCube",
        "body": "uimageCube",
        "description": "a handle for accessing an unsigned integer cube mapped texture"
    },
    "type-usamplerCubeArray": {
        "prefix": "usamplerCubeArray",
        "body": "usamplerCubeArray",
        "description": "a handle for accessing an unsigned integer cube map array texture"
    },
    "type-utextureCubeArray": {
        "prefix": "utextureCubeArray",
        "body": "utextureCubeArray",
        "description": "a handle for accessing an unsigned integer cube map array texture"
    },
    "type-uimageCubeArray": {
        "prefix": "uimageCubeArray",
        "body": "uimageCubeArray",
        "description": "a handle for accessing an unsigned integer cube map array texture"
    },
    "type-usamplerBuffer": {
        "prefix": "usamplerBuffer",
        "body": "usamplerBuffer",
        "description": "a handle for accessing an unsigned integer buffer texture"
    },
    "type-utextureBuffer": {
        "prefix": "utextureBuffer",
        "body": "utextureBuffer",
        "description": "a handle for accessing an unsigned integer buffer texture"
    },
    "type-uimageBuffer": {
        "prefix": "uimageBuffer",
        "body": "uimageBuffer",
        "description": "a handle for accessing an unsigned integer buffer texture"
    },
    "type-atomic_uint": {
        "prefix": "atomic_uint",
        "body": "atomic_uint",
        "description": "a handle for accessing an unsigned integer atomic counter"
    },
    "type-usubpassInput": {
        "prefix": "usubpassInput",
        "body": "usubpassInput",
        "description": "a handle for accessing an unsigned-integer subpass input"
    },
    "type-usubpassInputMS": {
        "prefix": "usubpassInputMS",
        "body": "usubpassInputMS",
        "description": "a handle for accessing a multi-sampled unsigned-integer subpass input"
    },
    // Sampler Opaque Types
    "type-sampler": {
        "prefix": "sampler",
        "body": "sampler",
        "description": "a handle for accessing state describing how to sample a texture"
    },
    "type-samplerShadow": {
        "prefix": "samplerShadow",
        "body": "samplerShadow",
        "description": "a handle for accessing state describing how to sample a depth texture with comparison"
    },
    // Storage Qualifiers
    "storage-const": {
        "prefix": "const",
        "body": "const",
        "description": "a variable whose value cannot be changed",
    },
    "storage-in": {
        "prefix": "in",
        "body": "in",
        "description": "linkage into a shader from a previous stage, variable is copied in"
    },
    "storage-out": {
        "prefix": "out",
        "body": "out",
        "description": "linkage into a shader from a previous stage, variable is copied in"
    },
    "storage-attribute": {
        "prefix": "attribute",
        "body": "attribute",
        "description": "compatibility profile only and vertex language only;\nsame as in when in a vertex shader"
    },
    "storage-uniform": {
        "prefix": "uniform",
        "body": "uniform",
        "description": "value does not change across the primitive being processed,\nuniforms form the linkage between a shader, API, and the application"
    },
    "storage-varying": {
        "prefix": "varying",
        "body": "varying",
        "description": "compatibility profile only and vertex and fragment languages only;\nsame as out when in a vertex shader and same as in when in a fragment shader"
    },
    "storage-buffer": {
        "prefix": "buffer",
        "body": "buffer",
        "description": "value is stored in a buffer object,\nand can be read or written both by shader invocations and the API"
    },
    "storage-shared": {
        "prefix": "shared",
        "body": "shared",
        "description": "compute shader only;\nvariable storage is shared across all work items in a workgroup"
    },
    // Auxiliary Storage Qualifier
    "storage-centroid": {
        "prefix": "centroid",
        "body": "centroid",
        "description": "centroid-based interpolation"
    },
    "storage-sample": {
        "prefix": "sample",
        "body": "sample",
        "description": "per-sample interpolation"
    },
    "storage-patch": {
        "prefix": "patch",
        "body": "patch",
        "description": "per-tessellation-patch attributes"
    },

    // Layout Qualifiers
    "layout-shared": {
        "prefix": "shared",
        "body": "shared",
        "description": ""
    },
    "layout-packed": {
        "prefix": "packed",
        "body": "packed",
        "description": ""
    },
    "layout-std140": {
        "prefix": "std140",
        "body": "std140",
        "description": ""
    },
    "layout-std430": {
        "prefix": "std430",
        "body": "std430",
        "description": ""
    },
    "layout-row_major": {
        "prefix": "row_major",
        "body": "row_major",
        "description": ""
    },
    "layout-column_major": {
        "prefix": "column_major",
        "body": "column_major",
        "description": ""
    },
    "layout-binding": {
        "prefix": "binding",
        "body": "binding =",
        "description": ""
    },
    "layout-offset": {
        "prefix": "offset",
        "body": "offset =",
        "description": ""
    },
    "layout-align": {
        "prefix": "align",
        "body": "align =",
        "description": ""
    },
    "layout-set": {
        "prefix": "set",
        "body": "set =",
        "description": ""
    },
    "layout-push_constant": {
        "prefix": "push_constant",
        "body": "push_constant",
        "description": ""
    },
    "layout-input_attachm": {
        "prefix": "input_attachm",
        "body": "input_attachm",
        "description": ""
    },
    "layout-ent_index": {
        "prefix": "ent_index",
        "body": "ent_index =",
        "description": ""
    },
    "layout-location": {
        "prefix": "location",
        "body": "location =",
        "description": ""
    },
    "layout-component": {
        "prefix": "component",
        "body": "component =",
        "description": ""
    },
    "layout-index": {
        "prefix": "index",
        "body": "index =",
        "description": ""
    },
    "layout-triangles": {
        "prefix": "triangles",
        "body": "triangles",
        "description": ""
    },
    "layout-quads": {
        "prefix": "quads",
        "body": "quads",
        "description": ""
    },
    "layout-isolines": {
        "prefix": "isolines",
        "body": "isolines",
        "description": ""
    },
    "layout-equal_spacing": {
        "prefix": "equal_spacing",
        "body": "equal_spacing",
        "description": ""
    },
    "layout-fractional_even_spacing": {
        "prefix": "fractional_even_spacing",
        "body": "fractional_even_spacing",
        "description": ""
    },
    "layout-fractional_odd_spacing": {
        "prefix": "fractional_odd_spacing",
        "body": "fractional_odd_spacing",
        "description": ""
    },
    "layout-cw": {
        "prefix": "cw",
        "body": "cw",
        "description": ""
    },
    "layout-ccw": {
        "prefix": "ccw",
        "body": "ccw",
        "description": ""
    },
    "layout-point_mode": {
        "prefix": "point_mode",
        "body": "point_mode",
        "description": ""
    },
    "layout-points": {
        "prefix": "points",
        "body": "points",
        "description": ""
    },
    "layout-lines": {
        "prefix": "lines",
        "body": "lines",
        "description": ""
    },
    "layout-lines_adjacency": {
        "prefix": "lines_adjacency",
        "body": "lines_adjacency",
        "description": ""
    },
    "layout-triangles_adjacency": {
        "prefix": "triangles_adjacency",
        "body": "triangles_adjacency",
        "description": ""
    },
    "layout-invocations": {
        "prefix": "invocations",
        "body": "invocations =",
        "description": ""
    },
    "layout-origin_upper_left": {
        "prefix": "origin_upper_left",
        "body": "origin_upper_left",
        "description": ""
    },
    "layout-pixel_center_integer": {
        "prefix": "pixel_center_integer",
        "body": "pixel_center_integer",
        "description": ""
    },
    "layout-early_fragment_tests": {
        "prefix": "early_fragment_tests",
        "body": "early_fragment_tests",
        "description": ""
    },
    "layout-local_size_x": {
        "prefix": "local_size_x",
        "body": "local_size_x =",
        "description": ""
    },
    "layout-local_size_y": {
        "prefix": "local_size_y",
        "body": "local_size_y =",
        "description": ""
    },
    "layout-local_size_z": {
        "prefix": "local_size_z",
        "body": "local_size_z =",
        "description": ""
    },
    "layout-local_size_x_id": {
        "prefix": "local_size_x_id",
        "body": "local_size_x_id =",
        "description": ""
    },
    "layout-local_size_y_id": {
        "prefix": "local_size_y_id",
        "body": "local_size_y_id =",
        "description": ""
    },
    "layout-local_size_z_id": {
        "prefix": "local_size_z_id",
        "body": "local_size_z_id =",
        "description": ""
    },
    "layout-xfb_buffer": {
        "prefix": "xfb_buffer",
        "body": "xfb_buffer =",
        "description": ""
    },
    "layout-xfb_stride": {
        "prefix": "xfb_stride",
        "body": "xfb_stride =",
        "description": ""
    },
    "layout-xfb_offset": {
        "prefix": "xfb_offset",
        "body": "xfb_offset =",
        "description": ""
    },
    "layout-vertices": {
        "prefix": "vertices",
        "body": "vertices =",
        "description": ""
    },
    "layout-line_strip": {
        "prefix": "line_strip",
        "body": "line_strip",
        "description": ""
    },
    "layout-triangle_strip": {
        "prefix": "triangle_strip",
        "body": "triangle_strip",
        "description": ""
    },
    "layout-max_vertices": {
        "prefix": "max_vertices",
        "body": "max_vertices =",
        "description": ""
    },
    "layout-stream": {
        "prefix": "stream",
        "body": "stream =",
        "description": ""
    },
    "layout-depth_any": {
        "prefix": "depth_any",
        "body": "depth_any",
        "description": ""
    },
    "layout-depth_greater": {
        "prefix": "depth_greater",
        "body": "depth_greater",
        "description": ""
    },
    "layout-depth_less": {
        "prefix": "depth_less",
        "body": "depth_less",
        "description": ""
    },
    "layout-depth_unchanged": {
        "prefix": "depth_unchanged",
        "body": "depth_unchanged",
        "description": ""
    },
    "layout-constant_id": {
        "prefix": "constant_id",
        "body": "constant_id =",
        "description": ""
    },
    "layout-rgba32f": {
        "prefix": "rgba32f",
        "body": "rgba32f",
        "description": ""
    },
    "layout-rgba16f": {
        "prefix": "rgba16f",
        "body": "rgba16f",
        "description": ""
    },
    "layout-rg32f": {
        "prefix": "rg32f",
        "body": "rg32f",
        "description": ""
    },
    "layout-rg16f": {
        "prefix": "rg16f",
        "body": "rg16f",
        "description": ""
    },
    "layout-r11f_g11f_b10f": {
        "prefix": "r11f_g11f_b10f",
        "body": "r11f_g11f_b10f",
        "description": ""
    },
    "layout-r32f": {
        "prefix": "r32f",
        "body": "r32f",
        "description": ""
    },
    "layout-r16f": {
        "prefix": "r16f",
        "body": "r16f",
        "description": ""
    },
    "layout-rgba16": {
        "prefix": "rgba16",
        "body": "rgba16",
        "description": ""
    },
    "layout-rgb10_a2": {
        "prefix": "rgb10_a2",
        "body": "rgb10_a2",
        "description": ""
    },
    "layout-rgba8": {
        "prefix": "rgba8",
        "body": "rgba8",
        "description": ""
    },
    "layout-rg16": {
        "prefix": "rg16",
        "body": "rg16",
        "description": ""
    },
    "layout-rg8": {
        "prefix": "rg8",
        "body": "rg8",
        "description": ""
    },
    "layout-r16": {
        "prefix": "r16",
        "body": "r16",
        "description": ""
    },
    "layout-r8": {
        "prefix": "r8",
        "body": "r8",
        "description": ""
    },
    "layout-rgba16_snorm": {
        "prefix": "rgba16_snorm",
        "body": "rgba16_snorm",
        "description": ""
    },
    "layout-rgba8_snorm": {
        "prefix": "rgba8_snorm",
        "body": "rgba8_snorm",
        "description": ""
    },
    "layout-rg16_snorm": {
        "prefix": "rg16_snorm",
        "body": "rg16_snorm",
        "description": ""
    },
    "layout-rg8_snorm": {
        "prefix": "rg8_snorm",
        "body": "rg8_snorm",
        "description": ""
    },
    "layout-r16_snorm": {
        "prefix": "r16_snorm",
        "body": "r16_snorm",
        "description": ""
    },
    "layout-r8_snorm": {
        "prefix": "r8_snorm",
        "body": "r8_snorm",
        "description": ""
    },
    "layout-rgba32i": {
        "prefix": "rgba32i",
        "body": "rgba32i",
        "description": ""
    },
    "layout-rgba16i": {
        "prefix": "rgba16i",
        "body": "rgba16i",
        "description": ""
    },
    "layout-rgba8i": {
        "prefix": "rgba8i",
        "body": "rgba8i",
        "description": ""
    },
    "layout-rg32i": {
        "prefix": "rg32i",
        "body": "rg32i",
        "description": ""
    },
    "layout-rg16i": {
        "prefix": "rg16i",
        "body": "rg16i",
        "description": ""
    },
    "layout-rg8i": {
        "prefix": "rg8i",
        "body": "rg8i",
        "description": ""
    },
    "layout-r32i": {
        "prefix": "r32i",
        "body": "r32i",
        "description": ""
    },
    "layout-r16i": {
        "prefix": "r16i",
        "body": "r16i",
        "description": ""
    },
    "layout-r8i": {
        "prefix": "r8i",
        "body": "r8i",
        "description": ""
    },
    "layout-rgba32ui": {
        "prefix": "rgba32ui",
        "body": "rgba32ui",
        "description": ""
    },
    "layout-rgba16ui": {
        "prefix": "rgba16ui",
        "body": "rgba16ui",
        "description": ""
    },
    "layout-rgb10_a2ui": {
        "prefix": "rgb10_a2ui",
        "body": "rgb10_a2ui",
        "description": ""
    },
    "layout-rgba8ui": {
        "prefix": "rgba8ui",
        "body": "rgba8ui",
        "description": ""
    },
    "layout-rg32ui": {
        "prefix": "rg32ui",
        "body": "rg32ui",
        "description": ""
    },
    "layout-rg16ui": {
        "prefix": "rg16ui",
        "body": "rg16ui",
        "description": ""
    },
    "layout-rg8ui": {
        "prefix": "rg8ui",
        "body": "rg8ui",
        "description": ""
    },
    "layout-r32ui": {
        "prefix": "r32ui",
        "body": "r32ui",
        "description": ""
    },
    "layout-r16ui": {
        "prefix": "r16ui",
        "body": "r16ui",
        "description": ""
    },
    "layout-r8ui": {
        "prefix": "r8ui",
        "body": "r8ui",
        "description": ""
    },
    
    // 8.1. Angle and Trigonometry Functions
    "genFType radians(genFType degrees)": {
        "prefix": "radians",
        "body": "radians(${1:degrees})$0",
        "description": "Converts degrees to radians, i.e., (π / 180) · degrees"
    },
    "genFType degrees(genFType radians)": {
        "prefix": "degrees",
        "body": "degrees(${1:radians})$0",
        "description": "Converts radians to degrees, i.e., (180 / π) · radians"
    },
    "genFType sin(genFType angle)": {
        "prefix": "sin",
        "body": "sin(${1:angle})$0",
        "description": "The standard trigonometric sine function"
    },
    "genFType cos(genFType angle)": {
        "prefix": "cos",
        "body": "cos(${1:angle})$0",
        "description": "The standard trigonometric cosine function"
    },
    "genFType tan(genFType angle)": {
        "prefix": "tan",
        "body": "tan(${1:angle})$0",
        "description": "The standard trigonometric tangent"
    },
    "genFType asin(genFType x)": {
        "prefix": "asin",
        "body": "asin(${1:x})$0",
        "description": "Arc sine.\nReturns an angle whose sine is x.\nThe range of values returned by this function is [-π / 2, π / 2].\nResults are undefined if |x| > 1"
    },
    "genFType acos(genFType x)": {
        "prefix": "acos",
        "body": "acos(${1:x})$0",
        "description": "Arc cosine.\nReturns an angle whose cosine is x.\nThe range of values returned by this function is [0,π].\nResults are undefined if |x| > 1"
    },
    "genFType atan(genFType y, genFType x)": {
        "prefix": "atan",
        "body": "atan(${1:y}, ${2:x})$0",
        "description": "Arc tangent.\nReturns an angle whose tangent is y / x.\nThe signs of x and y are used to determine what quadrant the angle is in.\nThe range of values returned by this function is [-π, π].\nResults are undefined if x and y are both 0"
    },
    "genFType atan(genFType y_over_x)": {
        "prefix": "atan",
        "body": "atan(${1:y_over_x})$0",
        "description": "Arc tangent.\nReturns an angle whose tangent is y_over_x.\nThe range of values returned by this function is [-π / 2, π / 2]"
    },

    // 8.2. Exponential Functions
    "genFType pow(genFType x, genFType y)": {
        "prefix": "pow",
        "body": "pow(${1:x}, ${2:y})$0",
        "description": "Returns x raised to the y power,\ni.e., x^y. Results are undefined if x < 0.\nResults are undefined if x = 0 and y ≤ 0"
    },
    "genFType exp(genFType x)": {
        "prefix": "exp",
        "body": "exp(${1:x})$0",
        "description": "Returns the natural exponentiation of x, i.e., e^x"
    },
    "genFType log(genFType x)": {
        "prefix": "log",
        "body": "log(${1:x})$0",
        "description": "Returns the natural logarithm of x,\ni.e., returns the value y which satisfies the equation x = e^y.\nResults are undefined if x ≤ 0"
    },
    "genFType exp2(genFType x)": {
        "prefix": "exp2",
        "body": "exp2(${1:x})$0",
        "description": "Returns 2 raised to the x power, i.e., 2^x"
    },
    "genFType log2(genFType x)": {
        "prefix": "log2",
        "body": "log2(${1:x})$0",
        "description": "Returns the base 2 logarithm of x,\ni.e., returns the value y which satisfies the equation x = 2^y.\nResults are undefined if x ≤ 0"
    },
    "genFType sqrt(genFType x)": {
        "prefix": "sqrt",
        "body": "sqrt(${1:x})$0",
        "description": "Returns sqrt(x). Results are undefined if x < 0"
    },
    "genDType sqrt(genDType x)": {
        "prefix": "sqrt",
        "body": "sqrt(${1:x})$0",
        "description": "Returns sqrt(x). Results are undefined if x < 0"
    },
    "genFType inversesqrt(genFType x)": {
        "prefix": "inversesqrt",
        "body": "inversesqrt(${1:x})$0",
        "description": "Returns 1 / sqrt(x). Results are undefined if x ≤ 0"
    },
    "genDType inversesqrt(genDType x)": {
        "prefix": "inversesqrt",
        "body": "inversesqrt(${1:x})$0",
        "description": "Returns 1 / sqrt(x). Results are undefined if x ≤ 0"
    },
    // 8.3. Common Functions
    "genFType abs(genFType x)": {
        "prefix": "abs",
        "body": "abs(${1:x})$0",
        "description": "Returns x if x ≥ 0;\notherwise it returns -x"
    },
    "genIType abs(genIType x)": {
        "prefix": "abs",
        "body": "abs(${1:x})$0",
        "description": "Returns x if x ≥ 0;\notherwise it returns -x"
    },
    "genDType abs(genDType x)": {
        "prefix": "abs",
        "body": "abs(${1:x})$0",
        "description": "Returns x if x ≥ 0;\notherwise it returns -x"
    },
    "genFType sign(genFType x)": {
        "prefix": "sign",
        "body": "sign(${1:x})$0",
        "description": "Returns 1.0 if x > 0, 0.0 if x = 0, or -1.0 if x < 0"
    },
    "genIType sign(genIType x)": {
        "prefix": "sign",
        "body": "sign(${1:x})$0",
        "description": "Returns 1.0 if x > 0, 0.0 if x = 0, or -1.0 if x < 0"
    },
    "genDType sign(genDType x)": {
        "prefix": "sign",
        "body": "sign(${1:x})$0",
        "description": "Returns 1.0 if x > 0, 0.0 if x = 0, or -1.0 if x < 0"
    },
    "genFType floor(genFType x)": {
        "prefix": "floor",
        "body": "floor(${1:x})$0",
        "description": "Returns a value equal to the nearest integer that is less than or equal to x"
    },
    "genDType floor(genDType x)": {
        "prefix": "floor",
        "body": "floor(${1:x})$0",
        "description": "Returns a value equal to the nearest integer that is less than or equal to x"
    },
    "genFType round(genFType x)": {
        "prefix": "round",
        "body": "round(${1:x})$0",
        "description": "Returns a value equal to the nearest integer to x.\nThe fraction 0.5 will round in a direction chosen by the implementation,\npresumably the direction that is fastest.\nThis includes the possibility that round(x) returns the same value as roundEven(x) for all values of x"
    },
    "genDType round(genDType x)": {
        "prefix": "round",
        "body": "round(${1:x})$0",
        "description": "Returns a value equal to the nearest integer to x.\nThe fraction 0.5 will round in a direction chosen by the implementation,\npresumably the direction that is fastest.\nThis includes the possibility that round(x) returns the same value as roundEven(x) for all values of x"
    },
    "genFType roundEven(genFType x)": {
        "prefix": "roundEven",
        "body": "roundEven(${1:x})$0",
        "description": "Returns a value equal to the nearest integer to x.\nA fractional part of 0.5 will round toward the nearest even integer.\n(Both 3.5 and 4.5 for x will return 4.0.)"
    },
    "genDType roundEven(genDType x)": {
        "prefix": "roundEven",
        "body": "roundEven(${1:x})$0",
        "description": "Returns a value equal to the nearest integer to x.\nA fractional part of 0.5 will round toward the nearest even integer.\n(Both 3.5 and 4.5 for x will return 4.0.)"
    },
    "genFType ceil(genFType x)": {
        "prefix": "ceil",
        "body": "ceil(${1:x})$0",
        "description": "Returns a value equal to the nearest integer that is greater than or equal to x"
    },
    "genDType ceil(genDType x)": {
        "prefix": "ceil",
        "body": "ceil(${1:x})$0",
        "description": "Returns a value equal to the nearest integer that is greater than or equal to x"
    },
    "genFType fract(genFType x)": {
        "prefix": "fract",
        "body": "fract(${1:x})$0",
        "description": "Returns x - floor(x)"
    },
    "genDType fract(genDType x)": {
        "prefix": "fract",
        "body": "fract(${1:x})$0",
        "description": "Returns x - floor(x)"
    },
    "genFType mod(genFType x, float y)": {
        "prefix": "mod",
        "body": "mod(${1:x}, ${2:y})$0",
        "description": "Modulus.\nReturns x - y · floor(x / y).\nNote that implementations may use a cheap approximation to the remainder,\nand the error can be large due to the discontinuity in floor.\nThis can produce mathematically unexpected results in some cases,\nsuch as mod(x,x) computing x rather than 0,\nand can also cause the result to have a different sign than the infinitely precise result"
    },
    "genFType mod(genFType x, genFType y)": {
        "prefix": "mod",
        "body": "mod(${1:x}, ${2:y})$0",
        "description": "Modulus.\nReturns x - y · floor(x / y).\nNote that implementations may use a cheap approximation to the remainder,\nand the error can be large due to the discontinuity in floor.\nThis can produce mathematically unexpected results in some cases,\nsuch as mod(x,x) computing x rather than 0,\nand can also cause the result to have a different sign than the infinitely precise result"
    },
    "genDType mod(genDType x, double y)": {
        "prefix": "mod",
        "body": "mod(${1:x}, ${2:y})$0",
        "description": "Modulus.\nReturns x - y · floor(x / y).\nNote that implementations may use a cheap approximation to the remainder,\nand the error can be large due to the discontinuity in floor.\nThis can produce mathematically unexpected results in some cases,\nsuch as mod(x,x) computing x rather than 0,\nand can also cause the result to have a different sign than the infinitely precise result"
    },
    "genDType mod(genDType x, genDType y)": {
        "prefix": "mod",
        "body": "mod(${1:x}, ${2:y})$0",
        "description": "Modulus.\nReturns x - y · floor(x / y).\nNote that implementations may use a cheap approximation to the remainder,\nand the error can be large due to the discontinuity in floor.\nThis can produce mathematically unexpected results in some cases,\nsuch as mod(x,x) computing x rather than 0,\nand can also cause the result to have a different sign than the infinitely precise result"
    },
    "genFType modf(genFType x, out genFType i)": {
        "prefix": "modf",
        "body": "modf(${1:x}, ${2:i})$0",
        "description": "Returns the fractional part of x and sets i to the integer part (as a whole number floating-point value).\nBoth the return value and the output parameter will have the same sign as x"
    },
    "genDType modf(genDType x, out genDType i)": {
        "prefix": "modf",
        "body": "modf(${1:x}, ${2:i})$0",
        "description": "Returns the fractional part of x and sets i to the integer part (as a whole number floating-point value).\nBoth the return value and the output parameter will have the same sign as x"
    },
    "genFType min(genFType x, genFType y)": {
        "prefix": "min",
        "body": "min(${1:x}, ${2:y})$0",
        "description": "Returns y if y < x; otherwise it returns x"
    },
    "genFType min(genFType x, float y)": {
        "prefix": "min",
        "body": "min(${1:x}, ${2:y})$0",
        "description": "Returns y if y < x; otherwise it returns x"
    },
    "genDType min(genDType x, genDType y)": {
        "prefix": "min",
        "body": "min(${1:x}, ${2:y})$0",
        "description": "Returns y if y < x; otherwise it returns x"
    },
    "genDType min(genDType x, double y)": {
        "prefix": "min",
        "body": "min(${1:x}, ${2:y})$0",
        "description": "Returns y if y < x; otherwise it returns x"
    },
    "genIType min(genIType x, genIType y)": {
        "prefix": "min",
        "body": "min(${1:x}, ${2:y})$0",
        "description": "Returns y if y < x; otherwise it returns x"
    },
    "genIType min(genIType x, int y)": {
        "prefix": "min",
        "body": "min(${1:x}, ${2:y})$0",
        "description": "Returns y if y < x; otherwise it returns x"
    },
    "genUType min(genUType x, genUType y)": {
        "prefix": "min",
        "body": "min(${1:x}, ${2:y})$0",
        "description": "Returns y if y < x; otherwise it returns x"
    },
    "genUType min(genUType x, uint y)": {
        "prefix": "min",
        "body": "min(${1:x}, ${2:y})$0",
        "description": "Returns y if y < x; otherwise it returns x"
    },
    "genFType max(genFType x, genFType y)": {
        "prefix": "max",
        "body": "max(${1:x}, ${2:y})$0",
        "description": "Returns y if x < y; otherwise it returns x"
    },
    "genFType max(genFType x, float y)": {
        "prefix": "max",
        "body": "max(${1:x}, ${2:y})$0",
        "description": "Returns y if x < y; otherwise it returns x"
    },
    "genDType max(genDType x, genDType y)": {
        "prefix": "max",
        "body": "max(${1:x}, ${2:y})$0",
        "description": "Returns y if x < y; otherwise it returns x"
    },
    "genDType max(genDType x, double y)": {
        "prefix": "max",
        "body": "max(${1:x}, ${2:y})$0",
        "description": "Returns y if x < y; otherwise it returns x"
    },
    "genIType max(genIType x, genIType y)": {
        "prefix": "max",
        "body": "max(${1:x}, ${2:y})$0",
        "description": "Returns y if x < y; otherwise it returns x"
    },
    "genIType max(genIType x, int y)": {
        "prefix": "max",
        "body": "max(${1:x}, ${2:y})$0",
        "description": "Returns y if x < y; otherwise it returns x"
    },
    "genUType max(genUType x, genUType y)": {
        "prefix": "max",
        "body": "max(${1:x}, ${2:y})$0",
        "description": "Returns y if x < y; otherwise it returns x"
    },
    "genUType max(genUType x, uint y)": {
        "prefix": "max",
        "body": "max(${1:x}, ${2:y})$0",
        "description": "Returns y if x < y; otherwise it returns x"
    },
    "genFType clamp(genFType x, genFType minVal, genFType maxVal)": {
        "prefix": "clamp",
        "body": "clamp(${1:x}, ${2:minVal}, ${3:maxVal})$0",
        "description": "Returns min(max(x, minVal), maxVal).\nResults are undefined if minVal > maxVal"
    },
    "genFType clamp(genFType x, float minVal, float maxVal)": {
        "prefix": "clamp",
        "body": "clamp(${1:x}, ${2:minVal}, ${3:maxVal})$0",
        "description": "Returns min(max(x, minVal), maxVal). \nResults are undefined if minVal > maxVal"
    },
    "genDType clamp(genDType x, genDType minVal, genDType maxVal)": {
        "prefix": "clamp",
        "body": "clamp(${1:x}, ${2:minVal}, ${3:maxVal})$0",
        "description": "Returns min(max(x, minVal), maxVal). \nResults are undefined if minVal > maxVal"
    },
    "genDType clamp(genDType x, double minVal, double maxVal)": {
        "prefix": "clamp",
        "body": "clamp(${1:x}, ${2:minVal}, ${3:maxVal})$0",
        "description": "Returns min(max(x, minVal), maxVal). \nResults are undefined if minVal > maxVal"
    },
    "genIType clamp(genIType x, genIType minVal, genIType maxVal)": {
        "prefix": "clamp",
        "body": "clamp(${1:x}, ${2:minVal}, ${3:maxVal})$0",
        "description": "Returns min(max(x, minVal), maxVal). \nResults are undefined if minVal > maxVal"
    },
    "genIType clamp(genIType x, int minVal, int maxVal)": {
        "prefix": "clamp",
        "body": "clamp(${1:x}, ${2:minVal}, ${3:maxVal})$0",
        "description": "Returns min(max(x, minVal), maxVal). \nResults are undefined if minVal > maxVal"
    },
    "genUType clamp(genUType x, genUType minVal, genUType maxVal)": {
        "prefix": "clamp",
        "body": "clamp(${1:x}, ${2:minVal}, ${3:maxVal})$0",
        "description": "Returns min(max(x, minVal), maxVal). \nResults are undefined if minVal > maxVal"
    },
    "genUType clamp(genUType x, uint minVal, uint maxVal)": {
        "prefix": "clamp",
        "body": "clamp(${1:x}, ${2:minVal}, ${3:maxVal})$0",
        "description": "Returns min(max(x, minVal), maxVal). \nResults are undefined if minVal > maxVal"
    },
    "genFType mix(genFType x, genFType y, genFType a)": {
        "prefix": "mix",
        "body": "mix(${1:x}, ${2:y}, ${3:a})$0",
        "description": "Returns the linear blend of x and y,\ni.e., x · (1 - a) + y · a"
    },
    "genFType mix(genFType x, genFType y, float a)": {
        "prefix": "mix",
        "body": "mix(${1:x}, ${2:y}, ${3:a})$0",
        "description": "Returns the linear blend of x and y,\ni.e., x · (1 - a) + y · a"
    },
    "genDType mix(genDType x, genDType y, genDType a)": {
        "prefix": "mix",
        "body": "mix(${1:x}, ${2:y}, ${3:a})$0",
        "description": "Returns the linear blend of x and y,\ni.e., x · (1 - a) + y · a"
    },
    "genDType mix(genDType x, genDType y, double a)": {
        "prefix": "mix",
        "body": "mix(${1:x}, ${2:y}, ${3:a})$0",
        "description": "Returns the linear blend of x and y,\ni.e., x · (1 - a) + y · a"
    },
    "genFType mix(genFType x, genFType y, genBType a)": {
        "prefix": "mix",
        "body": "mix(${1:x}, ${2:y}, ${3:a})$0",
        "description": "Selects which vector each returned component comes from.\nFor a component of a that is false, the corresponding component of x is returned.\nFor a component of a that is true,the corresponding component of y is returned.\nComponents of x and y that are not selected are allowed to be invalid floating-point values and will have no effect on the results.\nThus, this provides different functionality than, for example,\ngenFType mix(genFType x, genFType y, genFType(a)) where a is a Boolean vector"
    },
    "genDType mix(genDType x, genDType y, genBType a)": {
        "prefix": "mix",
        "body": "mix(${1:x}, ${2:y}, ${3:a})$0",
        "description": "Selects which vector each returned component comes from.\nFor a component of a that is false, the corresponding component of x is returned.\nFor a component of a that is true,the corresponding component of y is returned.\nComponents of x and y that are not selected are allowed to be invalid floating-point values and will have no effect on the results.\nThus, this provides different functionality than, for example,\ngenFType mix(genFType x, genFType y, genFType(a)) where a is a Boolean vector"
    },
    "genIType mix(genIType x, genIType y, genBType a)": {
        "prefix": "mix",
        "body": "mix(${1:x}, ${2:y}, ${3:a})$0",
        "description": "Selects which vector each returned component comes from.\nFor a component of a that is false, the corresponding component of x is returned.\nFor a component of a that is true,the corresponding component of y is returned.\nComponents of x and y that are not selected are allowed to be invalid floating-point values and will have no effect on the results.\nThus, this provides different functionality than, for example,\ngenFType mix(genFType x, genFType y, genFType(a)) where a is a Boolean vector"
    },
    "genUType mix(genUType x, genUType y, genBType a)": {
        "prefix": "mix",
        "body": "mix(${1:x}, ${2:y}, ${3:a})$0",
        "description": "Selects which vector each returned component comes from.\nFor a component of a that is false, the corresponding component of x is returned.\nFor a component of a that is true,the corresponding component of y is returned.\nComponents of x and y that are not selected are allowed to be invalid floating-point values and will have no effect on the results.\nThus, this provides different functionality than, for example,\ngenFType mix(genFType x, genFType y, genFType(a)) where a is a Boolean vector"
    },
    "genBType mix(genBType x, genBType y, genBType a)": {
        "prefix": "mix",
        "body": "mix(${1:x}, ${2:y}, ${3:a})$0",
        "description": "Selects which vector each returned component comes from.\nFor a component of a that is false, the corresponding component of x is returned.\nFor a component of a that is true, the corresponding component of y is returned.\nComponents of x and y that are not selected are allowed to be invalid floating-point values and will have no effect on the results.\nThus, this provides different functionality than, for example,\ngenFType mix(genFType x, genFType y, genFType(a)) where a is a Boolean vector"
    },
    // marker marker marker marker marker marker marker marker marker marker marker marker
    "genFType step(genFType edge, genFType x)": {
        "prefix": "step",
        "body": "step(${1:edge}, ${2:x})$0",
        "description": "Returns 0.0 if x < edge; otherwise it returns 1.0"
    },
    "genFType step(float edge, genFType x)": {
        "prefix": "step",
        "body": "step(${1:edge}, ${2:x})$0",
        "description": "Returns 0.0 if x < edge; otherwise it returns 1.0"
    },
    "genDType step(genDType edge, genDType x)": {
        "prefix": "step",
        "body": "step(${1:edge}, ${2:x})$0",
        "description": "Returns 0.0 if x < edge; otherwise it returns 1.0"
    },
    "genDType step(double edge, genDType x)": {
        "prefix": "step",
        "body": "step(${1:edge}, ${2:x})$0",
        "description": "Returns 0.0 if x < edge; otherwise it returns 1.0"
    },
    "genFType smoothstep(genFType edge0, genFType edge1, genFType x)": {
        "prefix": "smoothstep",
        "body": "smoothstep(${1:edge0}, ${2:edge1}, ${3:x})$0",
        "description": "Returns 0.0 if x ≤ edge0 and 1.0 if x ≥ edge1, and performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to: genFType t; t = clamp ((x - edge0) / (edge1 - edge0), 0, 1); return t * t * (3 - 2 * t); (And similarly for doubles.) Results are undefined if edge0 ≥ edge1"
    },
    "genFType smoothstep(float edge0, float edge1, genFType x)": {
        "prefix": "smoothstep",
        "body": "smoothstep(${1:edge0}, ${2:edge1}, ${3:x})$0",
        "description": "Returns 0.0 if x ≤ edge0 and 1.0 if x ≥ edge1, and performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to: genFType t; t = clamp ((x - edge0) / (edge1 - edge0), 0, 1); return t * t * (3 - 2 * t); (And similarly for doubles.) Results are undefined if edge0 ≥ edge1"
    },
    "genDType smoothstep(genDType edge0, genDType edge1, genDType x)": {
        "prefix": "smoothstep",
        "body": "smoothstep(${1:edge0}, ${2:edge1}, ${3:x})$0",
        "description": "Returns 0.0 if x ≤ edge0 and 1.0 if x ≥ edge1, and performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to: genFType t; t = clamp ((x - edge0) / (edge1 - edge0), 0, 1); return t * t * (3 - 2 * t); (And similarly for doubles.) Results are undefined if edge0 ≥ edge1"
    },
    "genDType smoothstep(double edge0, double edge1, genDType x)": {
        "prefix": "smoothstep",
        "body": "smoothstep(${1:edge0}, ${2:edge1}, ${3:x})$0",
        "description": "Returns 0.0 if x ≤ edge0 and 1.0 if x ≥ edge1, and performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to: genFType t; t = clamp ((x - edge0) / (edge1 - edge0), 0, 1); return t * t * (3 - 2 * t); (And similarly for doubles.) Results are undefined if edge0 ≥ edge1"
    },
    "genBType isnan(genFType x)": {
        "prefix": "isnan",
        "body": "isnan(${1:x})$0",
        "description": "Returns true if x holds a NaN. Returns false otherwise. Always returns false if NaNs are not implemented"
    },
    "genBType isnan(genDType x)": {
        "prefix": "isnan",
        "body": "isnan(${1:x})$0",
        "description": "Returns true if x holds a NaN. Returns false otherwise. Always returns false if NaNs are not implemented"
    },
    "genBType isinf(genFType x)": {
        "prefix": "isinf",
        "body": "isinf(${1:x})$0",
        "description": "Returns true if x holds a positive infinity or negative infinity. Returns false otherwise"
    },
    "genBType isinf(genDType x)": {
        "prefix": "isinf",
        "body": "isinf(${1:x})$0",
        "description": "Returns true if x holds a positive infinity or negative infinity. Returns false otherwise"
    },
    "genIType floatBitsToInt(highp genFType value)": {
        "prefix": "floatBitsToInt",
        "body": "floatBitsToInt(${1:value})$0",
        "description": "Returns a signed or unsigned integer value representing the encoding of a floating-point value. The float value’s bit-level representation is preserved"
    },
    "genUType floatBitsToUint(highp genFType value)": {
        "prefix": "floatBitsToUInt",
        "body": "floatBitsToUInt(${1:value})$0",
        "description": "Returns a signed or unsigned integer value representing the encoding of a floating-point value. The float value’s bit-level representation is preserved"
    },
    "genFType intBitsToFloat(highp genIType value)": {
        "prefix": "intBitsToFloat",
        "body": "intBitsToFloat(${1:value})$0",
        "description": "Returns a floating-point value corresponding to a signed or unsigned integer encoding of a floating-point value. If a NaN is passed in, it will not signal, and the resulting value is unspecified. If an Inf is passed in, the resulting value is the corresponding Inf. If a subnormal number is passed in, the result might be flushed to 0. Otherwise, the bit-level representation is preserved"
    },
    "genFType uintBitsToFloat(highp genUType value)": {
        "prefix": "uintBitsToFloat",
        "body": "uintBitsToFloat(${1:value})$0",
        "description": "Returns a floating-point value corresponding to a signed or unsigned integer encoding of a floating-point value. If a NaN is passed in, it will not signal, and the resulting value is unspecified. If an Inf is passed in, the resulting value is the corresponding Inf. If a subnormal number is passed in, the result might be flushed to 0. Otherwise, the bit-level representation is preserved"
    },
    "genFType fma(genFType a, genFType b, genFType c)": {
        "prefix": "fma",
        "body": "fma(${1:a}, ${2:b}, ${3:c})$0",
        "description": "Computes and returns a * b + c. In uses where the return value is eventually consumed by a variable declared as precise: • fma() is considered a single operation, whereas the expression a * b + c consumed by a variable declared precise is considered two operations. • The precision of fma() can differ from the precision of the expression a * b + c. • fma() will be computed with the same precision as any other fma() consumed by a precise variable, giving invariant results for the same input values of a, b, and c. Otherwise, in the absence of precise consumption, there are no special constraints on the number of operations or difference in precision between fma() and the expression a * b + c"
    },
    "genDType fma(genDType a, genDType b, genDType c)": {
        "prefix": "fma",
        "body": "fma(${1:a}, ${2:b}, ${3:c})$0",
        "description": "Computes and returns a * b + c. In uses where the return value is eventually consumed by a variable declared as precise: • fma() is considered a single operation, whereas the expression a * b + c consumed by a variable declared precise is considered two operations. • The precision of fma() can differ from the precision of the expression a * b + c. • fma() will be computed with the same precision as any other fma() consumed by a precise variable, giving invariant results for the same input values of a, b, and c. Otherwise, in the absence of precise consumption, there are no special constraints on the number of operations or difference in precision between fma() and the expression a * b + c"
    },
    "genFType frexp(highp genFType x, out highp genIType exp)": {
        "prefix": "frexp",
        "body": "frexp(${1:x}, ${2:exp})$0",
        "description": "Splits x into a floating-point significand in the range [0.5,1.0], and an integral exponent of two, such that x = significant · 2^exponent The significand is returned by the function and the exponent is returned in the parameter exp. For a floating-point value of zero, the significand and exponent are both zero. If an implementation supports signed zero, an input value of minus zero should return a significand of minus zero. For a floating-point value that is an infinity or is not a number, the results are undefined. If the input x is a vector, this operation is performed in a component-wise manner; the value returned by the function and the value written to exp are vectors with the same number of components as x"
    },
    "genDType frexp(genDType x, out genIType exp)": {
        "prefix": "frexp",
        "body": "frexp(${1:x}, ${2:exp})$0",
        "description": "Splits x into a floating-point significand in the range [0.5,1.0], and an integral exponent of two, such that x = significant · 2^exponent The significand is returned by the function and the exponent is returned in the parameter exp. For a floating-point value of zero, the significand and exponent are both zero. If an implementation supports signed zero, an input value of minus zero should return a significand of minus zero. For a floating-point value that is an infinity or is not a number, the results are undefined. If the input x is a vector, this operation is performed in a component-wise manner; the value returned by the function and the value written to exp are vectors with the same number of components as x"
    },
    "genFType ldexp(highp genFType x, highp genIType exp)": {
        "prefix": "ldexp",
        "body": "ldexp(${1:x}, ${2:exp})$0",
        "description": "Builds a floating-point number from x and the corresponding integral exponent of two in exp, returning: significand · 2^exponent If this product is too large to be represented in the floating-point type, the result is undefined. If exp is greater than +128 (single-precision) or +1024 (double-precision), the value returned is undefined. If exp is less than -126 (single- precision) or -1022 (double-precision), the value returned may be flushed to zero. Additionally, splitting the value into a significand and exponent using frexp() and then reconstructing a floating-point value using ldexp() should yield the original input for zero and all finite non- subnormal values. If the input x is a vector, this operation is performed in a component-wise manner; the value passed in exp and returned by the function are vectors with the same number of components as x."
    },
    "genDType ldexp(genDType x, genIType exp)": {
        "prefix": "ldexp",
        "body": "ldexp(${1:x}, ${2:exp})$0",
        "description": "Builds a floating-point number from x and the corresponding integral exponent of two in exp, returning: significand · 2^exponent If this product is too large to be represented in the floating-point type, the result is undefined. If exp is greater than +128 (single-precision) or +1024 (double-precision), the value returned is undefined. If exp is less than -126 (single- precision) or -1022 (double-precision), the value returned may be flushed to zero. Additionally, splitting the value into a significand and exponent using frexp() and then reconstructing a floating-point value using ldexp() should yield the original input for zero and all finite non- subnormal values. If the input x is a vector, this operation is performed in a component-wise manner; the value passed in exp and returned by the function are vectors with the same number of components as x."
    },
    // 8.4. Floating-Point Pack and Unpack Functions
    "highp uint packUnorm2x16(vec2 v)": {
        "prefix": "packUnorm2x16",
        "body": "packUnorm2x16(${1:v})$0",
        "description": "First, converts each component of the normalized floating-point value v into 16-bit (2x16) or 8-bit (4x8) integer values. Then, the results are packed into the returned 32-bit unsigned integer. The conversion for component c of v to fixed point is done as follows: packUnorm2x16: round(clamp(c, 0, +1) * 65535.0) packSnorm2x16: round(clamp(c, -1, +1) * 32767.0) packUnorm4x8: round(clamp(c, 0, +1) * 255.0) packSnorm4x8: round(clamp(c, -1, +1) * 127.0) The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits"
    },
    "highp uint packSnorm2x16(vec2 v)": {
        "prefix": "packSnorm2x16",
        "body": "packSnorm2x16(${1:v})$0",
        "description": "First, converts each component of the normalized floating-point value v into 16-bit (2x16) or 8-bit (4x8) integer values. Then, the results are packed into the returned 32-bit unsigned integer. The conversion for component c of v to fixed point is done as follows: packUnorm2x16: round(clamp(c, 0, +1) * 65535.0) packSnorm2x16: round(clamp(c, -1, +1) * 32767.0) packUnorm4x8: round(clamp(c, 0, +1) * 255.0) packSnorm4x8: round(clamp(c, -1, +1) * 127.0) The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits"
    },
    "uint packUnorm4x8(vec4 v)": {
        "prefix": "packUnorm4x8",
        "body": "packUnorm4x8(${1:v})$0",
        "description": "First, converts each component of the normalized floating-point value v into 16-bit (2x16) or 8-bit (4x8) integer values. Then, the results are packed into the returned 32-bit unsigned integer. The conversion for component c of v to fixed point is done as follows: packUnorm2x16: round(clamp(c, 0, +1) * 65535.0) packSnorm2x16: round(clamp(c, -1, +1) * 32767.0) packUnorm4x8: round(clamp(c, 0, +1) * 255.0) packSnorm4x8: round(clamp(c, -1, +1) * 127.0) The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits"
    },
    "uint packSnorm4x8(vec4 v)": {
        "prefix": "packSnorm4x8",
        "body": "packSnorm4x8(${1:v})$0",
        "description": "First, converts each component of the normalized floating-point value v into 16-bit (2x16) or 8-bit (4x8) integer values. Then, the results are packed into the returned 32-bit unsigned integer. The conversion for component c of v to fixed point is done as follows: packUnorm2x16: round(clamp(c, 0, +1) * 65535.0) packSnorm2x16: round(clamp(c, -1, +1) * 32767.0) packUnorm4x8: round(clamp(c, 0, +1) * 255.0) packSnorm4x8: round(clamp(c, -1, +1) * 127.0) The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits"
    },
    "vec2 unpackUnorm2x16(highp uint p)": {
        "prefix": "unpackUnorm2x16",
        "body": "unpackUnorm2x16(${1:p})$0",
        "description": "First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, a pair of 16-bit signed integers, four 8-bit unsigned integers, or four 8-bit signed integers, respectively. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector. The conversion for unpacked fixed-point value f to floating-point is done as follows: unpackUnorm2x16: f / 65535.0 unpackSnorm2x16: clamp(f / 32767.0, -1, +1) unpackUnorm4x8: f / 255.0 unpackSnorm4x8: clamp(f / 127.0, -1, +1) The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits"
    },
    "vec2 unpackSnorm2x16(highp uint p)": {
        "prefix": "unpackSnorm2x16",
        "body": "unpackSnorm2x16(${1:p})$0",
        "description": "First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, a pair of 16-bit signed integers, four 8-bit unsigned integers, or four 8-bit signed integers, respectively. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector. The conversion for unpacked fixed-point value f to floating-point is done as follows: unpackUnorm2x16: f / 65535.0 unpackSnorm2x16: clamp(f / 32767.0, -1, +1) unpackUnorm4x8: f / 255.0 unpackSnorm4x8: clamp(f / 127.0, -1, +1) The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits"
    },
    "vec4 unpackUnorm4x8(highp uint p)": {
        "prefix": "unpackUnorm4x8",
        "body": "unpackUnorm4x8(${1:p})$0",
        "description": "First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, a pair of 16-bit signed integers, four 8-bit unsigned integers, or four 8-bit signed integers, respectively. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector. The conversion for unpacked fixed-point value f to floating-point is done as follows: unpackUnorm2x16: f / 65535.0 unpackSnorm2x16: clamp(f / 32767.0, -1, +1) unpackUnorm4x8: f / 255.0 unpackSnorm4x8: clamp(f / 127.0, -1, +1) The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits"
    },
    "vec4 unpackSnorm4x8(highp uint p)": {
        "prefix": "unpackSnorm4x8",
        "body": "unpackSnorm4x8(${1:p})$0",
        "description": "First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, a pair of 16-bit signed integers, four 8-bit unsigned integers, or four 8-bit signed integers, respectively. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector. The conversion for unpacked fixed-point value f to floating-point is done as follows: unpackUnorm2x16: f / 65535.0 unpackSnorm2x16: clamp(f / 32767.0, -1, +1) unpackUnorm4x8: f / 255.0 unpackSnorm4x8: clamp(f / 127.0, -1, +1) The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits"
    },
    "uint packHalf2x16(vec2 v)": {
        "prefix": "packHalf2x16",
        "body": "packHalf2x16(${1:v})$0",
        "description": "Returns an unsigned integer obtained by converting the components of a two-component floating-point vector to the 16-bit floating-point representation of the API, and then packing these two 16-bit integers into a 32-bit unsigned integer. The first vector component specifies the 16 least- significant bits of the result; the second component specifies the 16 most-significant bits"
    },
    "vec2 unpackHalf2x16(uint v)": {
        "prefix": "unpackHalf2x16",
        "body": "unpackHalf2x16(${1:v})$0",
        "description": "Returns a two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting those values as 16-bit floating-point numbers according to the API, and converting them to 32-bit floating-point values. The first component of the vector is obtained from the 16 least-significant bits of v; the second component is obtained from the 16 most- significant bits of v"
    },
    "double packDouble2x32(uvec2 v)": {
        "prefix": "packDouble2x32",
        "body": "packDouble2x32(${1:v})$0",
        "description": "Returns a double-precision value obtained by packing the components of v into a 64-bit value. If an IEEE 754 Inf or NaN is created, it will not signal, and the resulting floating-point value is unspecified. Otherwise, the bit-level representation of v is preserved. The first vector component specifies the 32 least significant bits; the second component specifies the 32 most significant bits"
    },
    "uvec2 unpackDouble2x32(double v)": {
        "prefix": "unpackDouble2x32",
        "body": "unpackDouble2x32(${1:v})$0",
        "description": "Returns a two-component unsigned integer vector representation of v. The bit-level representation of v is preserved. The first component of the vector contains the 32 least significant bits of the double; the second component consists of the 32 most significant bits"
    },
    // 8.5. Geometric Functions
    "float length(genFType x)": {
        "prefix": "length",
        "body": "length(${1:x})$0",
        "description": "Returns the length of vector x, i.e., sqrt(x0^2 + x1^2 + …)"
    },
    "double length(genDType x)": {
        "prefix": "length",
        "body": "length(${1:x})$0",
        "description": "Returns the length of vector x, i.e., sqrt(x0^2 + x1^2 + …)"
    },
    "float distance(genFType p0, genFType p1)": {
        "prefix": "distance",
        "body": "distance(${1:p0}, ${2:p1})$0",
        "description": "Returns the distance between p0 and p1, i.e., length(p0 - p1)"
    },
    "double distance(genDType p0, genDType p1)": {
        "prefix": "distance",
        "body": "distance(${1:p0}, ${2:p1})$0",
        "description": "Returns the distance between p0 and p1, i.e., length(p0 - p1)"
    },
    "float dot(genFType x, genFType y)": {
        "prefix": "dot",
        "body": "dot(${1:x}, ${2:y})$0",
        "description": "Returns the dot product of x and y, i.e., x0 · y0 + x1 · y1 + …"
    },
    "double dot(genDType x, genDType y)": {
        "prefix": "dot",
        "body": "dot(${1:x}, ${2:y})$0",
        "description": "Returns the dot product of x and y, i.e., x0 · y0 + x1 · y1 + …"
    },
    "vec3 cross(vec3 x, vec3 y)": {
        "prefix": "cross",
        "body": "cross(${1:x}, ${2:y})$0",
        "description": "Returns the cross product of x and y, i.e., (x1 · y2 - y1 · x2, x2 · y0 - y2 · x0, x0 · y1 - y0 · x1)"
    },
    "dvec3 cross(dvec3 x, dvec3 y)": {
        "prefix": "cross",
        "body": "cross(${1:x}, ${2:y})$0",
        "description": "Returns the cross product of x and y, i.e., (x1 · y2 - y1 · x2, x2 · y0 - y2 · x0, x0 · y1 - y0 · x1)"
    },
    "genFType normalize(genFType x)": {
        "prefix": "normalize",
        "body": "normalize(${1:x})$0",
        "description": "Returns a vector in the same direction as x but with a length of 1, i.e. x / length(x)"
    },
    "genDType normalize(genDType x)": {
        "prefix": "normalize",
        "body": "normalize(${1:x})$0",
        "description": "Returns a vector in the same direction as x but with a length of 1, i.e. x / length(x)"
    },
    "vec4 ftransform()": {
        "prefix": "ftransform",
        "body": "ftransform()$0",
        "description": "Available only when using the compatibility profile. For core OpenGL, use invariant. For vertex shaders only. This function will ensure that the incoming vertex value will be transformed in a way that produces exactly the same result as would be produced by OpenGL’s fixed functionality transform. It is intended to be used to compute gl_Position, e.g. gl_Position = ftransform() This function should be used, for example, when an application is rendering the same geometry in separate passes, and one pass uses the fixed functionality path to render and another pass uses programmable shaders"
    },
    "genFType faceforward(genFType N, genFType I, genFType Nref)": {
        "prefix": "faceforward",
        "body": "faceforward(${1:N}, ${2:I}, ${3:Nref})$0",
        "description": "If dot(Nref, I) < 0 return N, otherwise return -N"
    },
    "genDType faceforward(genDType N, genDType I, genDType Nref)": {
        "prefix": "faceforward",
        "body": "faceforward(${1:N}, ${2:I}, ${3:Nref})$0",
        "description": "If dot(Nref, I) < 0 return N, otherwise return -N"
    },
    "genFType reflect(genFType I, genFType N)": {
        "prefix": "reflect",
        "body": "reflect(${1:I}, ${2:N})$0",
        "description": "For the incident vector I and surface orientation N, returns the reflection direction: I - 2 · dot(N, I) · N. N must already be normalized in order to achieve the desired result"
    },
    "genDType reflect(genDType I, genDType N)": {
        "prefix": "reflect",
        "body": "reflect(${1:I}, ${2:N})$0",
        "description": "For the incident vector I and surface orientation N, returns the reflection direction: I - 2 · dot(N, I) · N. N must already be normalized in order to achieve the desired result"
    },
    "genFType refract(genFType I, genFType N, float eta)": {
        "prefix": "refract",
        "body": "refract(${1:I}, ${2:N}, ${3:eta})$0",
        "description": "For the incident vector I and surface normal N, and the ratio of indices of refraction eta, return the refraction vector"
    },
    "genDType refract(genDType I, genDType N, double eta)": {
        "prefix": "refract",
        "body": "refract(${1:I}, ${2:N}, ${3:eta})$0",
        "description": "For the incident vector I and surface normal N, and the ratio of indices of refraction eta, return the refraction vector"
    },
    // 8.6. Matrix Functions
    "mat matrixCompMult(mat x, mat y)": {
        "prefix": "matrixCompMult",
        "body": "matrixCompMult(${1:x}, ${2:y})$0",
        "description": "Multiply matrix x by matrix y component-wise, i.e., result[i][j] is the scalar product of x[i][j] and y[i][j]. Note: to get linear algebraic matrix multiplication, use the multiply operator (*)"
    },
    "mat2 outerProduct(vec2 c, vec2 r)": {
        "prefix": "outerProduct",
        "body": "outerProduct(${1:c}, ${2:r})$0",
        "description": "Treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r"
    },
    "mat3 outerProduct(vec3 c, vec3 r)": {
        "prefix": "outerProduct",
        "body": "outerProduct(${1:c}, ${2:r})$0",
        "description": "Treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r"
    },
    "mat4 outerProduct(vec4 c, vec4 r)": {
        "prefix": "outerProduct",
        "body": "outerProduct(${1:c}, ${2:r})$0",
        "description": "Treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r"
    },
    "mat2x3 outerProduct(vec3 c, vec2 r)": {
        "prefix": "outerProduct",
        "body": "outerProduct(${1:c}, ${2:r})$0",
        "description": "Treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r"
    },
    "mat3x2 outerProduct(vec2 c, vec3 r)": {
        "prefix": "outerProduct",
        "body": "outerProduct(${1:c}, ${2:r})$0",
        "description": "Treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r"
    },
    "mat2x4 outerProduct(vec4 c, vec2 r)": {
        "prefix": "outerProduct",
        "body": "outerProduct(${1:c}, ${2:r})$0",
        "description": "Treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r"
    },
    "mat4x2 outerProduct(vec2 c, vec4 r)": {
        "prefix": "outerProduct",
        "body": "outerProduct(${1:c}, ${2:r})$0",
        "description": "Treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r"
    },
    "mat3x4 outerProduct(vec4 c, vec3 r)": {
        "prefix": "outerProduct",
        "body": "outerProduct(${1:c}, ${2:r})$0",
        "description": "Treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r"
    },
    "mat4x3 outerProduct(vec3 c, vec4 r)": {
        "prefix": "outerProduct",
        "body": "outerProduct(${1:c}, ${2:r})$0",
        "description": "Treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r"
    },
    "mat2 transpose(mat2 m)": {
        "prefix": "transpose",
        "body": "transpose(${1:m})$0",
        "description": "Returns a matrix that is the transpose of m. The input matrix m is not modified"
    },
    "mat3 transpose(mat3 m)": {
        "prefix": "transpose",
        "body": "transpose(${1:m})$0",
        "description": "Returns a matrix that is the transpose of m. The input matrix m is not modified"
    },
    "mat4 transpose(mat4 m)": {
        "prefix": "transpose",
        "body": "transpose(${1:m})$0",
        "description": "Returns a matrix that is the transpose of m. The input matrix m is not modified"
    },
    "mat2x3 transpose(mat3x2 m)": {
        "prefix": "transpose",
        "body": "transpose(${1:m})$0",
        "description": "Returns a matrix that is the transpose of m. The input matrix m is not modified"
    },
    "mat3x2 transpose(mat2x3 m)": {
        "prefix": "transpose",
        "body": "transpose(${1:m})$0",
        "description": "Returns a matrix that is the transpose of m. The input matrix m is not modified"
    },
    "mat2x4 transpose(mat4x2 m)": {
        "prefix": "transpose",
        "body": "transpose(${1:m})$0",
        "description": "Returns a matrix that is the transpose of m. The input matrix m is not modified"
    },
    "mat4x2 transpose(mat2x4 m)": {
        "prefix": "transpose",
        "body": "transpose(${1:m})$0",
        "description": "Returns a matrix that is the transpose of m. The input matrix m is not modified"
    },
    "mat3x4 transpose(mat4x3 m)": {
        "prefix": "transpose",
        "body": "transpose(${1:m})$0",
        "description": "Returns a matrix that is the transpose of m. The input matrix m is not modified"
    },
    "mat4x3 transpose(mat3x4 m)": {
        "prefix": "transpose",
        "body": "transpose(${1:m})$0",
        "description": "Returns a matrix that is the transpose of m. The input matrix m is not modified"
    },
    "float determinant(mat2 m)": {
        "prefix": "determinant",
        "body": "determinant(${1:m})$0",
        "description": "Returns the determinant of m"
    },
    "float determinant(mat3 m)": {
        "prefix": "determinant",
        "body": "determinant(${1:m})$0",
        "description": "Returns the determinant of m"
    },
    "float determinant(mat4 m)": {
        "prefix": "determinant",
        "body": "determinant(${1:m})$0",
        "description": "Returns the determinant of m"
    },
    "mat2 inverse(mat2 m)": {
        "prefix": "inverse",
        "body": "inverse(${1:m})$0",
        "description": "Returns a matrix that is the inverse of m. The input matrix m is not modified. The values in the returned matrix are undefined if m is singular or poorly-conditioned (nearly singular)"
    },
    "mat3 inverse(mat3 m)": {
        "prefix": "inverse",
        "body": "inverse(${1:m})$0",
        "description": "Returns a matrix that is the inverse of m. The input matrix m is not modified. The values in the returned matrix are undefined if m is singular or poorly-conditioned (nearly singular)"
    },
    "mat4 inverse(mat4 m)": {
        "prefix": "inverse",
        "body": "inverse(${1:m})$0",
        "description": "Returns a matrix that is the inverse of m. The input matrix m is not modified. The values in the returned matrix are undefined if m is singular or poorly-conditioned (nearly singular)"
    },
    // 8.7. Vector Relational Functions
    "bvec lessThan(vec x, vec y)": {
        "prefix": "lessThan",
        "body": "lessThan(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x < y"
    },
    "bvec lessThan(ivec x, ivec y)": {
        "prefix": "lessThan",
        "body": "lessThan(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x < y"
    },
    "bvec lessThan(uvec x, uvec y)": {
        "prefix": "lessThan",
        "body": "lessThan(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x < y"
    },
    "bvec lessThanEqual(vec x, vec y)": {
        "prefix": "lessThanEqual",
        "body": "lessThanEqual(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x ≤ y"
    },
    "bvec lessThanEqual(ivec x, ivec y)": {
        "prefix": "lessThanEqual",
        "body": "lessThanEqual(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x ≤ y"
    },
    "bvec lessThanEqual(uvec x, uvec y)": {
        "prefix": "lessThanEqual",
        "body": "lessThanEqual(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x ≤ y"
    },
    "bvec greaterThan(vec x, vec y)": {
        "prefix": "greaterThan",
        "body": "greaterThan(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x > y"
    },
    "bvec greaterThan(ivec x, ivec y)": {
        "prefix": "greaterThan",
        "body": "greaterThan(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x > y"
    },
    "bvec greaterThan(uvec x, uvec y)": {
        "prefix": "greaterThan",
        "body": "greaterThan(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x > y"
    },
    "bvec greaterThanEqual(vec x, vec y)": {
        "prefix": "greaterThanEqual",
        "body": "greaterThanEqual(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x ≥ y"
    },
    "bvec greaterThanEqual(ivec x, ivec y)": {
        "prefix": "greaterThanEqual",
        "body": "greaterThanEqual(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x ≥ y"
    },
    "bvec greaterThanEqual(uvec x, uvec y)": {
        "prefix": "greaterThanEqual",
        "body": "greaterThanEqual(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x ≥ y"
    },
    "bvec equal(vec x, vec y)": {
        "prefix": "equal",
        "body": "equal(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x == y"
    },
    "bvec equal(ivec x, ivec y)": {
        "prefix": "equal",
        "body": "equal(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x == y"
    },
    "bvec equal(uvec x, uvec y)": {
        "prefix": "equal",
        "body": "equal(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x == y"
    },
    "bvec equal(bvec x, bvec y)": {
        "prefix": "equal",
        "body": "equal(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x == y"
    },
    "bvec notEqual(vec x, vec y)": {
        "prefix": "notEqual",
        "body": "notEqual(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x ≠ y"
    },
    "bvec notEqual(ivec x, ivec y)": {
        "prefix": "notEqual",
        "body": "notEqual(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x ≠ y"
    },
    "bvec notEqual(uvec x, uvec y)": {
        "prefix": "notEqual",
        "body": "notEqual(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x ≠ y"
    },
    "bvec notEqual(bvec x, bvec y)": {
        "prefix": "notEqual",
        "body": "notEqual(${1:x}, ${2:y})$0",
        "description": "Returns the component-wise compare of x ≠ y"
    },
    "bool any(bvec x)": {
        "prefix": "any",
        "body": "any(${1:x})$0",
        "description": "Returns true if any component of x is true"
    },
    "bool all(bvec x)": {
        "prefix": "all",
        "body": "all(${1:x})$0",
        "description": "Returns true only if all components of x are true"
    },
    "bvec not(bvec x)": {
        "prefix": "not",
        "body": "not(${1:x})$0",
        "description": "Returns the component-wise logical complement of x"
    },
    // 8.8. Integer Functions
    "genUType uaddCarry(highp genUType x, highp genUType y, out lowp genUType carry)": {
        "prefix": "uaddCarry",
        "body": "uaddCarry(${1:x}, ${2:y}, ${3:carry})$0",
        "description": "Adds 32-bit unsigned integers x and y, returning the sum modulo 232. The value carry is set to zero if the sum was less than 232, or one otherwise"
    },
    "genUType usubBorrow(highp genUType x, highp genUType y, out lowp genUType borrow)": {
        "prefix": "usubBorrow",
        "body": "usubBorrow(${1:x}, ${2:y}, ${3:borrow})$0",
        "description": "Subtracts the 32-bit unsigned integer y from x, returning the difference if non-negative, or 232 plus the difference otherwise. The value borrow is set to zero if x ≥ y, or one otherwise"
    },
    "void umulExtended(highp genUType x, highp genUType y, out highp genUType msb, out highp genUType lsb)": {
        "prefix": "umulExtended",
        "body": "umulExtended(${1:x}, ${2:y}, ${3:mdb}, ${4:lsb})$0",
        "description": "Multiplies 32-bit unsigned or signed integers x and y, producing a 64-bit result. The 32 least-significant bits are returned in lsb. The 32 most-significant bits are returned in msb"
    },
    "void imulExtended(highp genIType x, highp genIType y, out highp genIType msb, out highp genIType lsb)": {
        "prefix": "imulExtended",
        "body": "imulExtended(${1:x}, ${2:y}, ${3:mdb}, ${4:lsb})$0",
        "description": "Multiplies 32-bit unsigned or signed integers x and y, producing a 64-bit result. The 32 least- significant bits are returned in lsb. The 32 most-significant bits are returned in msb"
    },
    "genIType bitfieldExtract(genIType value, int offset, int bits)": {
        "prefix": "bitfieldExtract",
        "body": "bitfieldExtract(${1:value}, ${2:offset}, ${3:bits})$0",
        "description": "Extracts bits [offset, offset + bits - 1] from value, returning them in the least significant bits of the result. For unsigned data types, the most significant bits of the result will be set to zero. For signed data types, the most significant bits will be set to the value of bit offset + bits - 1. If bits is zero, the result will be zero. The result will be undefined if offset or bits is negative, or if the sum of offset and bits is greater than the number of bits used to store the operand. Note that for vector versions of bitfieldExtract(), a single pair of offset and bits values is shared for all components"
    },
    "genUType bitfieldExtract(genUType value, int offset, int bits)": {
        "prefix": "bitfieldExtract",
        "body": "bitfieldExtract(${1:value}, ${2:offset}, ${3:bits})$0",
        "description": "Extracts bits [offset, offset + bits - 1] from value, returning them in the least significant bits of the result. For unsigned data types, the most significant bits of the result will be set to zero. For signed data types, the most significant bits will be set to the value of bit offset + bits - 1. If bits is zero, the result will be zero. The result will be undefined if offset or bits is negative, or if the sum of offset and bits is greater than the number of bits used to store the operand. Note that for vector versions of bitfieldExtract(), a single pair of offset and bits values is shared for all components"
    },
    "genIType bitfieldInsert(genIType base, genIType insert, int offset, int bits)": {
        "prefix": "bitfieldInsert",
        "body": "bitfieldInsert(${1:base}, ${2:inserts}, ${3:offset}, ${4:bits})$0",
        "description": "Inserts the bits least significant bits of insert into base. The result will have bits [offset, offset + bits - 1] taken from bits [0, bits - 1] of insert, and all other bits taken directly from the corresponding bits of base. If bits is zero, the result will simply be base. The result will be undefined if offset or bits is negative, or if the sum of offset and bits is greater than the number of bits used to store the operand. Note that for vector versions of bitfieldInsert(), a single pair of offset and bits values is shared for all components"
    },
    "genUType bitfieldInsert(genUType base, genUType insert, int offset, int bits)": {
        "prefix": "bitfieldInsert",
        "body": "bitfieldInsert(${1:base}, ${2:inserts}, ${3:offset}, ${4:bits})$0",
        "description": "Inserts the bits least significant bits of insert into base. The result will have bits [offset, offset + bits - 1] taken from bits [0, bits - 1] of insert, and all other bits taken directly from the corresponding bits of base. If bits is zero, the result will simply be base. The result will be undefined if offset or bits is negative, or if the sum of offset and bits is greater than the number of bits used to store the operand. Note that for vector versions of bitfieldInsert(), a single pair of offset and bits values is shared for all components"
    },
    "genIType bitfieldReverse(highp genIType value)": {
        "prefix": "bitfieldReverse",
        "body": "bitfieldReverse(${1:value})$0",
        "description": "Reverses the bits of value. The bit numbered n of the result will be taken from bit (bits - 1) - n of value, where bits is the total number of bits used to represent value"
    },
    "genUType bitfieldReverse(highp genUType value)": {
        "prefix": "bitfieldReverse",
        "body": "bitfieldReverse(${1:value})$0",
        "description": "Reverses the bits of value. The bit numbered n of the result will be taken from bit (bits - 1) - n of value, where bits is the total number of bits used to represent value"
    },
    "genIType bitCount(genIType value)": {
        "prefix": "bitCount",
        "body": "bitCount(${1:value})$0",
        "description": "Returns the number of one bits in the binary representation of value"
    },
    "genIType bitCount(genUType value)": {
        "prefix": "bitCount",
        "body": "bitCount(${1:value})$0",
        "description": "Returns the number of one bits in the binary representation of value"
    },
    "genIType findLSB(genIType value)": {
        "prefix": "findLSB",
        "body": "findLSB(${1:value})$0",
        "description": "Returns the bit number of the least significant one bit in the binary representation of value. If value is zero, -1 will be returned"
    },
    "genIType findLSB(genUType value)": {
        "prefix": "findLSB",
        "body": "findLSB(${1:value})$0",
        "description": "Returns the bit number of the least significant one bit in the binary representation of value. If value is zero, -1 will be returned"
    },
    "genIType findMSB(highp genIType value)": {
        "prefix": "findMSB",
        "body": "findMSB(${1:value})$0",
        "description": "Returns the bit number of the most significant bit in the binary representation of value. For positive integers, the result will be the bit number of the most significant one bit"
    },
    // 8.9. Texture Functions
    "int textureSize(gsampler1D sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec2 textureSize(gsampler2D sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec3 textureSize(gsampler3D sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec2 textureSize(gsamplerCube sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "int textureSize(sampler1DShadow sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec2 textureSize(sampler2DShadow sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec2 textureSize(samplerCubeShadow sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec3 textureSize(gsamplerCubeArray sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec3 textureSize(samplerCubeArrayShadow sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec2 textureSize(gsampler2DRect sampler)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec2 textureSize(sampler2DRectShadow sampler)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec2 textureSize(gsampler1DArray sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec2 textureSize(sampler1DArrayShadow sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec3 textureSize(gsampler2DArray sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec3 textureSize(sampler2DArrayShadow sampler, int lod)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler}, ${2:lod})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "int textureSize(gsamplerBuffer sampler)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec2 textureSize(gsampler2DMS sampler)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "ivec3 textureSize(gsampler2DMSArray sampler)": {
        "prefix": "textureSize",
        "body": "textureSize(${1:sampler})$0",
        "description": "Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL Specification. The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array"
    },
    "vec2 textureQueryLod(gsampler1D sampler, float P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(gsampler2D sampler, vec2 P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(gsampler3D sampler, vec3 P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(gsamplerCube sampler, vec3 P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(gsampler1DArray sampler, float P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(gsampler2DArray sampler, vec2 P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(gsamplerCubeArray sampler, vec3 P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(sampler1DShadow sampler, float P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(sampler2DShadow sampler, vec2 P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(samplerCubeShadow sampler, vec3 P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(sampler1DArrayShadow sampler, float P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(sampler2DArrayShadow sampler, vec2 P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "vec2 textureQueryLod(samplerCubeArrayShadow sampler, vec3 P)": {
        "prefix": "textureQueryLod",
        "body": "textureQueryLod(${1:sampler}, ${2:P})$0",
        "description": "Returns the mipmap array(s) that would be accessed in the x component of the return value. Returns the computed level-of-detail relative to the base level in the y component of the return value. If called on an incomplete texture, the results are undefined"
    },
    "int textureQueryLevels(gsampler1D sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(gsampler2D sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(gsampler3D sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(gsamplerCube sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(gsampler1DArray sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(gsampler2DArray sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(gsamplerCubeArray sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(sampler1DShadow sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(sampler2DShadow sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(samplerCubeShadow sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(sampler1DArrayShadow sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(sampler2DArrayShadow sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureQueryLevels(samplerCubeArrayShadow sampler)": {
        "prefix": "textureQueryLevels",
        "body": "textureQueryLevels(${1:sampler})$0",
        "description": "Returns the number of mipmap levels accessible in the texture associated with sampler, as defined in the OpenGL Specification. The value zero will be returned if no texture or an incomplete texture is associated with sampler. Available in all shader stages"
    },
    "int textureSamples(gsampler2DMS sampler)": {
        "prefix": "textureSamples",
        "body": "textureSamples(${1:sampler})$0",
        "description": "Returns the number of samples of the texture or textures bound to sampler"
    },
    "int textureSamples(gsampler2DMSArray sampler)": {
        "prefix": "textureSamples",
        "body": "textureSamples(${1:sampler})$0",
        "description": "Returns the number of samples of the texture or textures bound to sampler"
    },
    "gvec4 texture(gsampler1D sampler, float P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsampler1D sampler, float P, float bias)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsampler2D sampler, vec2 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsampler2D sampler, vec2 P, float bias)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsampler3D sampler, vec3 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsampler3D sampler, vec3 P, float bias)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsamplerCube sampler, vec3 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsamplerCube sampler, vec3 P, float bias)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(sampler1DShadow sampler, vec3 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(sampler1DShadow sampler, vec3 P, float bias]": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(sampler2DShadow sampler, vec3 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(sampler2DShadow sampler, vec3 P, float bias)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:sP}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(samplerCubeShadow sampler, vec4 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(samplerCubeShadow sampler, vec4 P, float bias)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsampler2DArray sampler, vec3 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsampler2DArray sampler, vec3 P, float bias)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsamplerCubeArray sampler, vec4 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsamplerCubeArray sampler, vec4 P, float bias)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsampler1DArray sampler, vec2 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsampler1DArray sampler, vec2 P, float bias)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:sP}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(sampler1DArrayShadow sampler, vec3 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(sampler1DArrayShadow sampler, vec3 P, float bias)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(sampler2DArrayShadow sampler, vec4 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 texture(gsampler2DRect sampler, vec2 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(sampler2DRectShadow sampler, vec3 P)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "float texture(samplerCubeArrayShadow sampler, vec4 P, float compare)": {
        "prefix": "texture",
        "body": "texture(${1:sampler}, ${2:P}, ${3:compare})$0",
        "description": "Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as Dref and the array layer comes from the last component of P. When compare is not present, the last component of P is used as Dref and the array layer comes from the second to last component of P. (The second component of P is unused for 1D shadow lookups.) For non-shadow forms: the array layer comes from the last component of P"
    },
    "gvec4 textureProj(gsampler1D sampler, vec2 P)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler1D sampler, vec2 P, float bias)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler1D sampler, vec4 P)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler1D sampler, vec4 P, float bias)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler2D sampler, vec3 P)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler2D sampler, vec3 P, float bias": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler2D sampler, vec4 P)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler2D sampler, vec4 P, float bias)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler3D sampler, vec4 P": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler3D sampler, vec4 P, float bias)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "float textureProj(sampler1DShadow sampler, vec4 P)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "float textureProj(sampler1DShadow sampler, vec4 P, float bias)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "float textureProj(sampler2DShadow sampler, vec4 P)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "float textureProj(sampler2DShadow sampler, vec4 P, float bias)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P}, ${3:bias})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler2DRect sampler, vec3 P)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureProj(gsampler2DRect sampler, vec4 P)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "float textureProj(sampler2DRectShadow sampler, vec4 P)": {
        "prefix": "textureProj",
        "body": "textureProj(${1:sampler}, ${2:P})$0",
        "description": "Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as Dref. The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture"
    },
    "gvec4 textureLod(gsampler1D sampler, float P, float lod)": {
        "prefix": "textureLod",
        "body": "textureLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λbase] and sets the partial derivatives as follows: (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL Specification.) ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0"
    },
    "gvec4 textureLod(gsampler2D sampler, vec2 P, float lod)": {
        "prefix": "textureLod",
        "body": "textureLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λbase] and sets the partial derivatives as follows: (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL Specification.) ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0"
    },
    "gvec4 textureLod(gsampler3D sampler, vec3 P, float lod)": {
        "prefix": "textureLod",
        "body": "textureLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λbase] and sets the partial derivatives as follows: (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL Specification.) ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0"
    },
    "gvec4 textureLod(gsamplerCube sampler, vec3 P, float lod)": {
        "prefix": "textureLod",
        "body": "textureLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λbase] and sets the partial derivatives as follows: (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL Specification.) ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0"
    },
    "float textureLod(sampler2DShadow sampler, vec3 P, float lod)": {
        "prefix": "textureLod",
        "body": "textureLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λbase] and sets the partial derivatives as follows: (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL Specification.) ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0"
    },
    "float textureLod(sampler1DShadow sampler, vec3 P, float lod)": {
        "prefix": "textureLod",
        "body": "textureLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λbase] and sets the partial derivatives as follows: (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL Specification.) ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0"
    },
    "gvec4 textureLod(gsampler1DArray sampler, vec2 P, float lod)": {
        "prefix": "textureLod",
        "body": "textureLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λbase] and sets the partial derivatives as follows: (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL Specification.) ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0"
    },
    "float textureLod(sampler1DArrayShadow sampler, vec3 P, float lod)": {
        "prefix": "textureLod",
        "body": "textureLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λbase] and sets the partial derivatives as follows: (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL Specification.) ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0"
    },
    "gvec4 textureLod(gsampler2DArray sampler, vec3 P, float lod)": {
        "prefix": "textureLod",
        "body": "textureLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λbase] and sets the partial derivatives as follows: (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL Specification.) ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0"
    },
    "gvec4 textureLod(gsamplerCubeArray sampler, vec4 P, float lod)": {
        "prefix": "textureLod",
        "body": "textureLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λbase] and sets the partial derivatives as follows: (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL Specification.) ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0"
    },
    "gvec4 textureOffset(gsampler1D sampler, float P, int offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 textureOffset(gsampler1D sampler, float P, int offset, float bias)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:bias})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 textureOffset(gsampler2D sampler, vec2 P, ivec2 offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 textureOffset(gsampler2D sampler, vec2 P, ivec2 offset, float bias)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:bias})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 textureOffset(gsampler3D sampler, vec3 P, ivec3 offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 textureOffset(gsampler3D sampler, vec3 P, ivec3 offset, float bias)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:bias})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "float textureOffset(sampler2DShadow sampler, vec3 P, ivec2 offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "float textureOffset(sampler2DShadow sampler, vec3 P, ivec2 offset, float bias)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:bias})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 textureOffset(gsampler2DRect sampler, vec2 P, ivec2 offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "float textureOffset(sampler2DRectShadow sampler, vec3 P, ivec2 offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "float textureOffset(sampler1DShadow sampler, vec3 P, int offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "float textureOffset(sampler1DShadow sampler, vec3 P, int offset, float bias) ": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:bias})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 textureOffset(gsampler1DArray sampler, vec2 P, int offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 textureOffset(gsampler1DArray sampler, vec2 P, int offset, float bias)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:bias})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 textureOffset(gsampler2DArray sampler, vec3 P, ivec2 offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 textureOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, float bias)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:bias})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "float textureOffset(sampler1DArrayShadow sampler, vec3 P, int offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "float textureOffset(sampler1DArrayShadow sampler, vec3 P, int offset, float bias)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:bias})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "float textureOffset(sampler2DArrayShadow sampler, vec4 P, ivec2 offset)": {
        "prefix": "textureOffset",
        "body": "textureOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation- dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL Specification, where offset is (δu, δv, δw). Note that texel offsets are also not supported for cube maps"
    },
    "gvec4 texelFetch(gsampler1D sampler, int P, int lod)": {
        "prefix": "texelFetch",
        "body": "texelFetch(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Use integer texture coordinate P to lookup a single texel from sampler. The array layer comes from the last component of P for the array forms. The level-of-detail lod (if present) is as described in sections 11.1.3.2 “Texel Fetches” and 8.14.1 “Scale Factor and Level of Detail” of the OpenGL Specification. 184"
    },
    "gvec4 texelFetch(gsampler2D sampler, ivec2 P, int lod)": {
        "prefix": "texelFetch",
        "body": "texelFetch(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Use integer texture coordinate P to lookup a single texel from sampler. The array layer comes from the last component of P for the array forms. The level-of-detail lod (if present) is as described in sections 11.1.3.2 “Texel Fetches” and 8.14.1 “Scale Factor and Level of Detail” of the OpenGL Specification. 184"
    },
    "gvec4 texelFetch(gsampler3D sampler, ivec3 P, int lod)": {
        "prefix": "texelFetch",
        "body": "texelFetch(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Use integer texture coordinate P to lookup a single texel from sampler. The array layer comes from the last component of P for the array forms. The level-of-detail lod (if present) is as described in sections 11.1.3.2 “Texel Fetches” and 8.14.1 “Scale Factor and Level of Detail” of the OpenGL Specification. 184"
    },
    "gvec4 texelFetch(gsampler2DRect sampler, ivec2 P)": {
        "prefix": "texelFetch",
        "body": "texelFetch(${1:sampler}, ${2:P})$0",
        "description": "Use integer texture coordinate P to lookup a single texel from sampler. The array layer comes from the last component of P for the array forms. The level-of-detail lod (if present) is as described in sections 11.1.3.2 “Texel Fetches” and 8.14.1 “Scale Factor and Level of Detail” of the OpenGL Specification. 184"
    },
    "gvec4 texelFetch(gsampler1DArray sampler, ivec2 P, int lod)": {
        "prefix": "texelFetch",
        "body": "texelFetch(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Use integer texture coordinate P to lookup a single texel from sampler. The array layer comes from the last component of P for the array forms. The level-of-detail lod (if present) is as described in sections 11.1.3.2 “Texel Fetches” and 8.14.1 “Scale Factor and Level of Detail” of the OpenGL Specification. 184"
    },
    "gvec4 texelFetch(gsampler2DArray sampler, ivec3 P, int lod)": {
        "prefix": "texelFetch",
        "body": "texelFetch(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Use integer texture coordinate P to lookup a single texel from sampler. The array layer comes from the last component of P for the array forms. The level-of-detail lod (if present) is as described in sections 11.1.3.2 “Texel Fetches” and 8.14.1 “Scale Factor and Level of Detail” of the OpenGL Specification. 184"
    },
    "gvec4 texelFetch(gsamplerBuffer sampler, int P)": {
        "prefix": "texelFetch",
        "body": "texelFetch(${1:sampler}, ${2:P})$0",
        "description": "Use integer texture coordinate P to lookup a single texel from sampler. The array layer comes from the last component of P for the array forms. The level-of-detail lod (if present) is as described in sections 11.1.3.2 “Texel Fetches” and 8.14.1 “Scale Factor and Level of Detail” of the OpenGL Specification. 184"
    },
    "gvec4 texelFetch(gsampler2DMS sampler, ivec2 P, int sample)": {
        "prefix": "texelFetch",
        "body": "texelFetch(${1:sampler}, ${2:P}, ${3:sample})$0",
        "description": "Use integer texture coordinate P to lookup a single texel from sampler. The array layer comes from the last component of P for the array forms. The level-of-detail lod (if present) is as described in sections 11.1.3.2 “Texel Fetches” and 8.14.1 “Scale Factor and Level of Detail” of the OpenGL Specification. 184"
    },
    "gvec4 texelFetch(gsampler2DMSArray sampler, ivec3 P, int sample)": {
        "prefix": "texelFetch",
        "body": "texelFetch(${1:sampler}, ${2:P}, ${3:sample})$0",
        "description": "Use integer texture coordinate P to lookup a single texel from sampler. The array layer comes from the last component of P for the array forms. The level-of-detail lod (if present) is as described in sections 11.1.3.2 “Texel Fetches” and 8.14.1 “Scale Factor and Level of Detail” of the OpenGL Specification. 184"
    },
    "gvec4 texelFetchOffset(gsampler1D sampler, int P, int lod, int offset)": {
        "prefix": "texelFetchOffset",
        "body": "texelFetchOffset(${1:sampler}, ${2:P}, ${2:lod}, ${4:offset})$0",
        "description": "Fetch a single texel as in texelFetch, offset by offset as described in textureOffset"
    },
    "gvec4 texelFetchOffset(gsampler2D sampler, ivec2 P, int lod, ivec2 offset)": {
        "prefix": "texelFetchOffset",
        "body": "texelFetchOffset(${1:sampler}, ${2:P}, ${2:lod}, ${4:offset})$0",
        "description": "Fetch a single texel as in texelFetch, offset by offset as described in textureOffset"
    },
    "gvec4 texelFetchOffset(gsampler3D sampler, ivec3 P, int lod, ivec3 offset)": {
        "prefix": "texelFetchOffset",
        "body": "texelFetchOffset(${1:sampler}, ${2:P}, ${2:lod}, ${4:offset})$0",
        "description": "Fetch a single texel as in texelFetch, offset by offset as described in textureOffset"
    },
    "gvec4 texelFetchOffset(gsampler2DRect sampler, ivec2 P, ivec2 offset)": {
        "prefix": "texelFetchOffset",
        "body": "texelFetchOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Fetch a single texel as in texelFetch, offset by offset as described in textureOffset"
    },
    "gvec4 texelFetchOffset(gsampler1DArray sampler, ivec2 P, int lod, int offset)": {
        "prefix": "texelFetchOffset",
        "body": "texelFetchOffset(${1:sampler}, ${2:P}, ${2:lod}, ${4:offset})$0",
        "description": "Fetch a single texel as in texelFetch, offset by offset as described in textureOffset"
    },
    "gvec4 texelFetchOffset(gsampler2DArray sampler, ivec3 P, int lod, ivec2 offset)": {
        "prefix": "texelFetchOffset",
        "body": "texelFetchOffset(${1:sampler}, ${2:P}, ${2:lod}, ${4:offset})$0",
        "description": "Fetch a single texel as in texelFetch, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler1D sampler, vec2 P, int offset)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler1D sampler, vec2 P, int offset, float bias)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset}, ${3:bias})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler1D sampler, vec4 P, int offset)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler1D sampler, vec4 P, int offset, float bias)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset}, ${3:bias})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler2D sampler, vec3 P, ivec2 offset)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler2D sampler, vec3 P, ivec2 offset, float bias)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset}, ${3:bias})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler2D sampler, vec4 P, ivec2 offset)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler2D sampler, vec4 P, ivec2 offset, float bias)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset}, ${3:bias})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler3D sampler, vec4 P, ivec3 offset)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler3D sampler, vec4 P, ivec3 offset, float bias)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset}, ${3:bias})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler2DRect sampler, vec3 P, ivec2 offset)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureProjOffset(gsampler2DRect sampler, vec4 P, ivec2 offset)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "float textureProjOffset(sampler2DRectShadow sampler, vec4 P, ivec2 offset)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "float textureProjOffset(sampler1DShadow sampler, vec4 P, int offset)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "float textureProjOffset(sampler1DShadow sampler, vec4 P, int offset, float bias)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset}, ${3:bias})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, float bias)": {
        "prefix": "textureProjOffset",
        "body": "textureProjOffset(${1:sample}, ${2:P}, ${3:offset}, ${3:bias})$0",
        "description": "Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset"
    },
    "gvec4 textureLodOffset(gsampler1D sampler, float P, float lod, int offset)": {
        "prefix": "textureLodOffset",
        "body": "textureLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset texture lookup with explicit level-of- detail. See textureLod and textureOffset"
    },
    "gvec4 textureLodOffset(gsampler2D sampler, vec2 P, float lod, ivec2 offset)": {
        "prefix": "textureLodOffset",
        "body": "textureLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset texture lookup with explicit level-of- detail. See textureLod and textureOffset"
    },
    "gvec4 textureLodOffset(gsampler3D sampler, vec3 P, float lod, ivec3 offset)": {
        "prefix": "textureLodOffset",
        "body": "textureLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset texture lookup with explicit level-of- detail. See textureLod and textureOffset"
    },
    "float textureLodOffset(sampler1DShadow sampler, vec3 P, float lod, int offset)": {
        "prefix": "textureLodOffset",
        "body": "textureLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset texture lookup with explicit level-of- detail. See textureLod and textureOffset"
    },
    "float textureLodOffset(sampler2DShadow sampler, vec3 P, float lod, ivec2 offset)": {
        "prefix": "textureLodOffset",
        "body": "textureLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset texture lookup with explicit level-of- detail. See textureLod and textureOffset"
    },
    "gvec4 textureLodOffset(gsampler1DArray sampler, vec2 P, float lod, int offset)": {
        "prefix": "textureLodOffset",
        "body": "textureLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset texture lookup with explicit level-of- detail. See textureLod and textureOffset"
    },
    "gvec4 textureLodOffset(gsampler2DArray sampler, vec3 P, float lod, ivec2 offset)": {
        "prefix": "textureLodOffset",
        "body": "textureLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset texture lookup with explicit level-of- detail. See textureLod and textureOffset"
    },
    "float textureLodOffset(sampler1DArrayShadow sampler, vec3 P, float lod, int offset)": {
        "prefix": "textureLodOffset",
        "body": "textureLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset texture lookup with explicit level-of- detail. See textureLod and textureOffset"
    },
    "gvec4 textureProjLod(gsampler1D sampler, vec2 P, float lod)": {
        "prefix": "textureProjLod",
        "body": "textureProjLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a projective texture lookup with explicit level-of-detail. See textureProj and textureLod"
    },
    "gvec4 textureProjLod(gsampler1D sampler, vec4 P, float lod)": {
        "prefix": "textureProjLod",
        "body": "textureProjLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a projective texture lookup with explicit level-of-detail. See textureProj and textureLod"
    },
    "gvec4 textureProjLod(gsampler2D sampler, vec3 P, float lod)": {
        "prefix": "textureProjLod",
        "body": "textureProjLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a projective texture lookup with explicit level-of-detail. See textureProj and textureLod"
    },
    "gvec4 textureProjLod(gsampler2D sampler, vec4 P, float lod)": {
        "prefix": "textureProjLod",
        "body": "textureProjLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a projective texture lookup with explicit level-of-detail. See textureProj and textureLod"
    },
    "gvec4 textureProjLod(gsampler3D sampler, vec4 P, float lod)": {
        "prefix": "textureProjLod",
        "body": "textureProjLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a projective texture lookup with explicit level-of-detail. See textureProj and textureLod"
    },
    "float textureProjLod(sampler1DShadow sampler, vec4 P, float lod)": {
        "prefix": "textureProjLod",
        "body": "textureProjLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a projective texture lookup with explicit level-of-detail. See textureProj and textureLod"
    },
    "float textureProjLod(sampler2DShadow sampler, vec4 P, float lod)": {
        "prefix": "textureProjLod",
        "body": "textureProjLod(${1:sampler}, ${2:P}, ${3:lod})$0",
        "description": "Do a projective texture lookup with explicit level-of-detail. See textureProj and textureLod"
    },
    "gvec4 textureProjLodOffset(gsampler1D sampler, vec2 P, float lod, int offset)": {
        "prefix": "textureProjLodOffset",
        "body": "textureProjLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset projective texture lookup with explicit level-of-detail. See textureProj, textureLod, and textureOffset"
    },
    "gvec4 textureProjLodOffset(gsampler1D sampler, vec4 P, float lod, int offset)": {
        "prefix": "textureProjLodOffset",
        "body": "textureProjLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset projective texture lookup with explicit level-of-detail. See textureProj, textureLod, and textureOffset"
    },
    "gvec4 textureProjLodOffset(gsampler2D sampler, vec3 P, float lod, ivec2 offset)": {
        "prefix": "textureProjLodOffset",
        "body": "textureProjLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset projective texture lookup with explicit level-of-detail. See textureProj, textureLod, and textureOffset"
    },
    "gvec4 textureProjLodOffset(gsampler2D sampler, vec4 P, float lod, ivec2 offset)": {
        "prefix": "textureProjLodOffset",
        "body": "textureProjLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset projective texture lookup with explicit level-of-detail. See textureProj, textureLod, and textureOffset"
    },
    "gvec4 textureProjLodOffset(gsampler3D sampler, vec4 P, float lod, ivec3 offset)": {
        "prefix": "textureProjLodOffset",
        "body": "textureProjLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset projective texture lookup with explicit level-of-detail. See textureProj, textureLod, and textureOffset"
    },
    "float textureProjLodOffset(sampler1DShadow sampler, vec4 P, float lod, int offset)": {
        "prefix": "textureProjLodOffset",
        "body": "textureProjLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset projective texture lookup with explicit level-of-detail. See textureProj, textureLod, and textureOffset"
    },
    "float textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset)": {
        "prefix": "textureProjLodOffset",
        "body": "textureProjLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$0",
        "description": "Do an offset projective texture lookup with explicit level-of-detail. See textureProj, textureLod, and textureOffset"
    },
    "gvec4 textureGrad(gsampler1D sampler, float P, float dPdx, float dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "gvec4 textureGrad(gsampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "gvec4 textureGrad(gsampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "gvec4 textureGrad(gsamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "gvec4 textureGrad(gsampler2DRect sampler, vec2 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "float textureGrad(sampler2DRectShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "float textureGrad(sampler1DShadow sampler, vec3 P, float dPdx, float dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "gvec4 textureGrad(gsampler1DArray sampler, vec2 P, float dPdx, float dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "gvec4 textureGrad(gsampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "float textureGrad(sampler1DArrayShadow sampler, vec3 P, float dPdx, float dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "float textureGrad(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "float textureGrad(samplerCubeShadow sampler, vec4 P, vec3 dPdx, vec3 dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "float textureGrad(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "gvec4 textureGrad(gsamplerCubeArray sampler, vec4 P, vec3 dPdx, vec3 dPdy)": {
        "prefix": "textureGrad",
        "body": "textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face"
    },
    "gvec4 textureGradOffset(gsampler1D sampler, float P, float dPdx, float dPdy, int offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "gvec4 textureGradOffset(gsampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "gvec4 textureGradOffset(gsampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy, ivec3 offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "gvec4 textureGradOffset(gsampler2DRect sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "float textureGradOffset(sampler2DRectShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "float textureGradOffset(sampler1DShadow sampler, vec3 P, float dPdx, float dPdy, int offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "float textureGradOffset(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "gvec4 textureGradOffset(gsampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "gvec4 textureGradOffset(gsampler1DArray sampler, vec2 P, float dPdx, float dPdy, int offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "float textureGradOffset(sampler1DArrayShadow sampler, vec3 P, float dPdx, float dPdy, int offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "float textureGradOffset(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureGradOffset",
        "body": "textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset"
    },
    "gvec4 textureProjGrad(gsampler1D sampler, vec2 P, float dPdx, float dPdy)": {
        "prefix": "textureProjGrad",
        "body": "textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected"
    },
    "gvec4 textureProjGrad(gsampler1D sampler, vec4 P, float dPdx, float dPdy)": {
        "prefix": "textureProjGrad",
        "body": "textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected"
    },
    "gvec4 textureProjGrad(gsampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureProjGrad",
        "body": "textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected"
    },
    "gvec4 textureProjGrad(gsampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureProjGrad",
        "body": "textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected"
    },
    "gvec4 textureProjGrad(gsampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy)": {
        "prefix": "textureProjGrad",
        "body": "textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected"
    },
    "gvec4 textureProjGrad(gsampler2DRect sampler, vec3 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureProjGrad",
        "body": "textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected"
    },
    "gvec4 textureProjGrad(gsampler2DRect sampler, vec4 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureProjGrad",
        "body": "textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected"
    },
    "float textureProjGrad(sampler2DRectShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureProjGrad",
        "body": "textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected"
    },
    "float textureProjGrad(sampler1DShadow sampler, vec4 P, float dPdx, float dPdy)": {
        "prefix": "textureProjGrad",
        "body": "textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected"
    },
    "float textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy)": {
        "prefix": "textureProjGrad",
        "body": "textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$0",
        "description": "Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected"
    },
    "gvec4 textureProjGradOffset(gsampler1D sampler, vec2 P, float dPdx, float dPdy, int offset)": {
        "prefix": "textureProjGradOffset",
        "body": "textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset"
    },
    "gvec4 textureProjGradOffset(gsampler1D sampler, vec4 P, float dPdx, float dPdy, int offset)": {
        "prefix": "textureProjGradOffset",
        "body": "textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset"
    },
    "gvec4 textureProjGradOffset(gsampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureProjGradOffset",
        "body": "textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset"
    },
    "gvec4 textureProjGradOffset(gsampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureProjGradOffset",
        "body": "textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset"
    },
    "gvec4 textureProjGradOffset(gsampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset)": {
        "prefix": "textureProjGradOffset",
        "body": "textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset"
    },
    "gvec4 textureProjGradOffset(gsampler2DRect sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureProjGradOffset",
        "body": "textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset"
    },
    "gvec4 textureProjGradOffset(gsampler2DRect sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureProjGradOffset",
        "body": "textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset"
    },
    "float textureProjGradOffset(sampler2DRectShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureProjGradOffset",
        "body": "textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset"
    },
    "float textureProjGradOffset(sampler1DShadow sampler, vec4 P, float dPdx, float dPdy, int offset)": {
        "prefix": "textureProjGradOffset",
        "body": "textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset"
    },
    "float textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset)": {
        "prefix": "textureProjGradOffset",
        "body": "textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$0",
        "description": "Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset"
    },
    "gvec4 textureGather(gsampler2D sampler, vec2 P)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "gvec4 textureGather(gsampler2D sampler, vec2 P, int comp)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P}, ${3:comp})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "gvec4 textureGather(gsampler2DArray sampler, vec3 P)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "gvec4 textureGather(gsampler2DArray sampler, vec3 P, int comp])": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P}, ${3:comp})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "gvec4 textureGather(gsamplerCube sampler, vec3 P)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "gvec4 textureGather(gsamplerCube sampler, vec3 P, int comp)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P}, ${3:comp})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "gvec4 textureGather(gsamplerCubeArray sampler, vec4 P)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "gvec4 textureGather(gsamplerCubeArray sampler, vec4 P, int comp)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P}, ${3:comp})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "gvec4 textureGather(gsampler2DRect sampler, vec2 P)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "gvec4 textureGather(gsampler2DRect sampler, vec2 P, int comp)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P}, ${3:comp})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "vec4 textureGather(sampler2DShadow sampler, vec2 P, float refZ)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P}, ${3:refZ})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "vec4 textureGather(sampler2DArrayShadow sampler, vec3 P, float refZ)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P}, ${3:refZ})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "vec4 textureGather(samplerCubeShadow sampler, vec3 P, float refZ)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P}, ${3:refZ})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "vec4 textureGather(samplerCubeArrayShadow sampler, vec4 P, float refZ)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P}, ${3:refZ})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "vec4 textureGather(sampler2DRectShadow sampler, vec2 P, float refZ)": {
        "prefix": "textureGather",
        "body": "textureGather(${1:sampler}, ${2:P}, ${3:refZ})$0",
        "description": "Returns the value vec4(Sample_i0_j1(P, base).comp, Sample_i1_j1(P, base).comp, Sample_i1_j0(P, base).comp, Sample_i0_j0(P, base).comp) If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result"
    },
    "gvec4 textureGatherOffset(gsampler2D sampler, vec2 P, ivec2 offset, int comp)": {
        "prefix": "textureGatherOffset",
        "body": "textureGatherOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:comp})$0",
        "description": "Perform a texture gather operation as in textureGather by offset as described in textureOffset except that the offset can be variable (non constant) and the implementation- dependent minimum and maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively"
    },
    "gvec4 textureGatherOffset(gsampler2D sampler, vec2 P, ivec2 offset)": {
        "prefix": "textureGatherOffset",
        "body": "textureGatherOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Perform a texture gather operation as in textureGather by offset as described in textureOffset except that the offset can be variable (non constant) and the implementation- dependent minimum and maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively"
    },
    "gvec4 textureGatherOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, int comp)": {
        "prefix": "textureGatherOffset",
        "body": "textureGatherOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:comp})$0",
        "description": "Perform a texture gather operation as in textureGather by offset as described in textureOffset except that the offset can be variable (non constant) and the implementation- dependent minimum and maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively"
    },
    "gvec4 textureGatherOffset(gsampler2DArray sampler, vec3 P, ivec2 offset)": {
        "prefix": "textureGatherOffset",
        "body": "textureGatherOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Perform a texture gather operation as in textureGather by offset as described in textureOffset except that the offset can be variable (non constant) and the implementation- dependent minimum and maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively"
    },
    "vec4 textureGatherOffset(sampler2DShadow sampler, vec2 P, float refZ, ivec2 offset)": {
        "prefix": "textureGatherOffset",
        "body": "textureGatherOffset(${1:sampler}, ${2:P}, ${3:refZ}, ${4:offset})$0",
        "description": "Perform a texture gather operation as in textureGather by offset as described in textureOffset except that the offset can be variable (non constant) and the implementation- dependent minimum and maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively"
    },
    "vec4 textureGatherOffset(sampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offset)": {
        "prefix": "textureGatherOffset",
        "body": "textureGatherOffset(${1:sampler}, ${2:P}, ${3:refZ}, ${4:offset})$0",
        "description": "Perform a texture gather operation as in textureGather by offset as described in textureOffset except that the offset can be variable (non constant) and the implementation- dependent minimum and maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively"
    },
    "gvec4 textureGatherOffset(gsampler2DRect sampler, vec2 P, ivec2 offset, int comp)": {
        "prefix": "textureGatherOffset",
        "body": "textureGatherOffset(${1:sampler}, ${2:P}, ${3:offset}, ${4:comp})$0",
        "description": "Perform a texture gather operation as in textureGather by offset as described in textureOffset except that the offset can be variable (non constant) and the implementation- dependent minimum and maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively"
    },
    "gvec4 textureGatherOffset(gsampler2DRect sampler, vec2 P, ivec2 offset)": {
        "prefix": "textureGatherOffset",
        "body": "textureGatherOffset(${1:sampler}, ${2:P}, ${3:offset})$0",
        "description": "Perform a texture gather operation as in textureGather by offset as described in textureOffset except that the offset can be variable (non constant) and the implementation- dependent minimum and maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively"
    },
    "vec4 textureGatherOffset(sampler2DRectShadow sampler, vec2 P, float refZ, ivec2 offset)": {
        "prefix": "textureGatherOffset",
        "body": "textureGatherOffset(${1:sampler}, ${2:P}, ${3:refZ}, ${4:offset})$0",
        "description": "Perform a texture gather operation as in textureGather by offset as described in textureOffset except that the offset can be variable (non constant) and the implementation- dependent minimum and maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively"
    },
    "gvec4 textureGatherOffsets(gsampler2D sampler, vec2 P, ivec2 offsets[4], int comp)": {
        "prefix": "textureGatherOffsets",
        "body": "textureGatherOffsets(${1:sampler}, ${2:P}, ${3:offsets}, ${4:comp})$0",
        "description": "Operate identically to textureGatherOffset except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the corresponding offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel LINEAR footprint, and then selecting the texel i0 j0 of that footprint. The specified values in offsets must be constant integral expressions"
    },
    "gvec4 textureGatherOffsets(gsampler2D sampler, vec2 P, ivec2 offsets[4])": {
        "prefix": "textureGatherOffsets",
        "body": "textureGatherOffsets(${1:sampler}, ${2:P}, ${3:offsets})$0",
        "description": "Operate identically to textureGatherOffset except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the corresponding offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel LINEAR footprint, and then selecting the texel i0 j0 of that footprint. The specified values in offsets must be constant integral expressions"
    },
    "gvec4 textureGatherOffsets(gsampler2DArray sampler, vec3 P, ivec2 offsets[4], int comp)": {
        "prefix": "textureGatherOffsets",
        "body": "textureGatherOffsets(${1:sampler}, ${2:P}, ${3:offsets}, ${4:comp})$0",
        "description": "Operate identically to textureGatherOffset except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the corresponding offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel LINEAR footprint, and then selecting the texel i0 j0 of that footprint. The specified values in offsets must be constant integral expressions"
    },
    "gvec4 textureGatherOffsets(gsampler2DArray sampler, vec3 P, ivec2 offsets[4])": {
        "prefix": "textureGatherOffsets",
        "body": "textureGatherOffsets(${1:sampler}, ${2:P}, ${3:offsets})$0",
        "description": "Operate identically to textureGatherOffset except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the corresponding offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel LINEAR footprint, and then selecting the texel i0 j0 of that footprint. The specified values in offsets must be constant integral expressions"
    },
    "vec4 textureGatherOffsets(sampler2DShadow sampler, vec2 P, float refZ, ivec2 offsets[4])": {
        "prefix": "textureGatherOffsets",
        "body": "textureGatherOffsets(${1:sampler}, ${2:P}, ${3:offsets})$0",
        "description": "Operate identically to textureGatherOffset except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the corresponding offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel LINEAR footprint, and then selecting the texel i0 j0 of that footprint. The specified values in offsets must be constant integral expressions"
    },
    "vec4 textureGatherOffsets(sampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offsets[4])": {
        "prefix": "textureGatherOffsets",
        "body": "textureGatherOffsets(${1:sampler}, ${2:P}, ${3:offsets})$0",
        "description": "Operate identically to textureGatherOffset except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the corresponding offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel LINEAR footprint, and then selecting the texel i0 j0 of that footprint. The specified values in offsets must be constant integral expressions"
    },
    "gvec4 textureGatherOffsets(gsampler2DRect sampler, vec2 P, ivec2 offsets[4], int comp)": {
        "prefix": "textureGatherOffsets",
        "body": "textureGatherOffsets(${1:sampler}, ${2:P}, ${3:offsets}, ${4:comp})$0",
        "description": "Operate identically to textureGatherOffset except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the corresponding offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel LINEAR footprint, and then selecting the texel i0 j0 of that footprint. The specified values in offsets must be constant integral expressions"
    },
    "gvec4 textureGatherOffsets(gsampler2DRect sampler, vec2 P, ivec2 offsets[4])": {
        "prefix": "textureGatherOffsets",
        "body": "textureGatherOffsets(${1:sampler}, ${2:P}, ${3:offsets})$0",
        "description": "Operate identically to textureGatherOffset except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the corresponding offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel LINEAR footprint, and then selecting the texel i0 j0 of that footprint. The specified values in offsets must be constant integral expressions"
    },
    "vec4 textureGatherOffsets(sampler2DRectShadow sampler, vec2 P, float refZ, ivec2 offsets[4])": {
        "prefix": "textureGatherOffsets",
        "body": "textureGatherOffsets(${1:sampler}, ${2:P}, ${3:refZ}, ${4:offsets})$0",
        "description": "Operate identically to textureGatherOffset except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the corresponding offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel LINEAR footprint, and then selecting the texel i0 j0 of that footprint. The specified values in offsets must be constant integral expressions"
    },
    "vec4 texture1D(sampler1D sampler, float coord, float bias)": {
        "prefix": "texture1D",
        "body": "texture1D(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "See corresponding signature above without “1D” in the name"
    },
    "vec4 texture1D(sampler1D sampler, float coord)": {
        "prefix": "texture1D",
        "body": "texture1D(${1:sampler}, ${2:coord})$0",
        "description": "See corresponding signature above without “1D” in the name"
    },
    "vec4 texture1DProj(sampler1D sampler, vec2 coord, float bias)": {
        "prefix": "texture1DProj",
        "body": "texture1DProj(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "See corresponding signature above without “1D” in the name"
    },
    "vec4 texture1DProj(sampler1D sampler, vec2 coord)": {
        "prefix": "texture1DProj",
        "body": "texture1DProj(${1:sampler}, ${2:coord})$0",
        "description": "See corresponding signature above without “1D” in the name"
    },
    "vec4 texture1DProj(sampler1D sampler, vec4 coord, float bias)": {
        "prefix": "texture1DProj",
        "body": "texture1DProj(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "See corresponding signature above without “1D” in the name"
    },
    "vec4 texture1DProj(sampler1D sampler, vec4 coord)": {
        "prefix": "texture1DProj",
        "body": "texture1DProj(${1:sampler}, ${2:coord})$0",
        "description": "See corresponding signature above without “1D” in the name"
    },
    "vec4 texture1DLod(sampler1D sampler, float coord, float lod)": {
        "prefix": "texture1DLod",
        "body": "texture1DLod(${1:sampler}, ${2:coord}, ${3:lod})$0",
        "description": "See corresponding signature above without “1D” in the name"
    },
    "vec4 texture1DProjLod(sampler1D sampler, vec2 coord, float lod)": {
        "prefix": "texture1DProjLod",
        "body": "texture1DProjLod(${1:sampler}, ${2:coord}, ${3:lod})$0",
        "description": "See corresponding signature above without “1D” in the name"
    },
    "vec4 texture1DProjLod(sampler1D sampler, vec4 coord, float lod)": {
        "prefix": "texture1DProjLod",
        "body": "texture1DProjLod(${1:sampler}, ${2:coord}, ${3:lod})$0",
        "description": "See corresponding signature above without “1D” in the name"
    },
    "vec4 texture2D(sampler2D sampler, vec2 coord, float bias)": {
        "prefix": "texture2D",
        "body": "texture2D(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "See corresponding signature above without “2D” in the name"
    },
    "vec4 texture2D(sampler2D sampler, vec2 coord)": {
        "prefix": "texture2D",
        "body": "texture2D(${1:sampler}, ${2:coord})$0",
        "description": "See corresponding signature above without “2D” in the name"
    },
    "vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias)": {
        "prefix": "texture2DProj",
        "body": "texture2DProj(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "See corresponding signature above without “2D” in the name"
    },
    "vec4 texture2DProj(sampler2D sampler, vec3 coord)": {
        "prefix": "texture2DProj",
        "body": "texture2DProj(${1:sampler}, ${2:coord})$0",
        "description": "See corresponding signature above without “2D” in the name"
    },
    "vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias)": {
        "prefix": "texture2DProj",
        "body": "texture2DProj(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "See corresponding signature above without “2D” in the name"
    },
    "vec4 texture2DProj(sampler2D sampler, vec4 coord)": {
        "prefix": "texture2DProj",
        "body": "texture2DProj(${1:sampler}, ${2:coord})$0",
        "description": "See corresponding signature above without “2D” in the name"
    },
    "vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod)": {
        "prefix": "texture2DLod",
        "body": "texture2DLod(${1:sampler}, ${2:coord}, ${3:lod})$0",
        "description": "See corresponding signature above without “2D” in the name"
    },
    "vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod)": {
        "prefix": "texture2DProjLod",
        "body": "texture2DProjLod(${1:sampler}, ${2:coord}, ${3:lod})$0",
        "description": "See corresponding signature above without “2D” in the name"
    },
    "vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod)": {
        "prefix": "texture2DProjLod",
        "body": "texture2DProjLod(${1:sampler}, ${2:coord}, ${3:lod})$0",
        "description": "See corresponding signature above without “2D” in the name"
    },
    "vec4 texture3D(sampler3D sampler, vec3 coord, float bias)": {
        "prefix": "texture3D",
        "body": "texture3D(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "See corresponding signature above without “3D” in the name. Use the texture coordinate coord to do a texture lookup in the 3D texture currently bound to sampler. For the projective (“Proj”) versions, the texture coordinate is divided by coord.q"
    },
    "vec4 texture3D(sampler3D sampler, vec3 coord)": {
        "prefix": "texture3D",
        "body": "texture3D(${1:sampler}, ${2:coord})$0",
        "description": "See corresponding signature above without “3D” in the name. Use the texture coordinate coord to do a texture lookup in the 3D texture currently bound to sampler. For the projective (“Proj”) versions, the texture coordinate is divided by coord.q"
    },
    "vec4 texture3DProj(sampler3D sampler, vec4 coord, float bias)": {
        "prefix": "texture3DProj",
        "body": "texture3DProj(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "See corresponding signature above without “3D” in the name. Use the texture coordinate coord to do a texture lookup in the 3D texture currently bound to sampler. For the projective (“Proj”) versions, the texture coordinate is divided by coord.q"
    },
    "vec4 texture3DProj(sampler3D sampler, vec4 coord)": {
        "prefix": "texture3DProj",
        "body": "texture3DProj(${1:sampler}, ${2:coord})$0",
        "description": "See corresponding signature above without “3D” in the name. Use the texture coordinate coord to do a texture lookup in the 3D texture currently bound to sampler. For the projective (“Proj”) versions, the texture coordinate is divided by coord.q"
    },
    "vec4 texture3DLod(sampler3D sampler, vec3 coord, float lod)": {
        "prefix": "texture3DLod",
        "body": "texture3DLod(${1:sampler}, ${2:coord}, ${3:lod})$0",
        "description": "See corresponding signature above without “3D” in the name. Use the texture coordinate coord to do a texture lookup in the 3D texture currently bound to sampler. For the projective (“Proj”) versions, the texture coordinate is divided by coord.q"
    },
    "vec4 texture3DProjLod(sampler3D sampler, vec4 coord, float lod)": {
        "prefix": "texture3DProjLod",
        "body": "texture3DProjLod(${1:sampler}, ${2:coord}, ${3:lod})$0",
        "description": "See corresponding signature above without “3D” in the name. Use the texture coordinate coord to do a texture lookup in the 3D texture currently bound to sampler. For the projective (“Proj”) versions, the texture coordinate is divided by coord.q"
    },
    "vec4 textureCube(samplerCube sampler, vec3 coord, float bias)": {
        "prefix": "textureCube",
        "body": "textureCube(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "See corresponding signature above without “Cube” in the name"
    },
    "vec4 textureCube(samplerCube sampler, vec3 coord)": {
        "prefix": "textureCube",
        "body": "textureCube(${1:sampler}, ${2:coord})$0",
        "description": "See corresponding signature above without “Cube” in the name"
    },
    "vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod)": {
        "prefix": "textureCubeLod",
        "body": "textureCubeLod(${1:sampler}, ${2:coord}, ${3:lod})$0",
        "description": "See corresponding signature above without “Cube” in the name"
    },
    "vec4 shadow1D(sampler1DShadow sampler, vec3 coord, float bias)": {
        "prefix": "shadow1D",
        "body": "shadow1D(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow1D(sampler1DShadow sampler, vec3 coord)": {
        "prefix": "shadow1D",
        "body": "shadow1D(${1:sampler}, ${2:coord})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow2D(sampler2DShadow sampler, vec3 coord, float bias)": {
        "prefix": "shadow2D",
        "body": "shadow2D(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow2D(sampler2DShadow sampler, vec3 coord)": {
        "prefix": "shadow2D",
        "body": "shadow2D(${1:sampler}, ${2:coord})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow1DProj(sampler1DShadow sampler, vec4 coord, float bias)": {
        "prefix": "shadow1DProj",
        "body": "shadow1DProj(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow1DProj(sampler1DShadow sampler, vec4 coord)": {
        "prefix": "shadow1DProj",
        "body": "shadow1DProj(${1:sampler}, ${2:coord})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow2DProj(sampler2DShadow sampler, vec4 coord, float bias)": {
        "prefix": "shadow2DProj",
        "body": "shadow2DProj(${1:sampler}, ${2:coord}, ${3:bias})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow2DProj(sampler2DShadow sampler, vec4 coord)": {
        "prefix": "shadow2DProj",
        "body": "shadow2DProj(${1:sampler}, ${2:coord})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow1DLod(sampler1DShadow sampler, vec3 coord, float lod)": {
        "prefix": "shadow1DLod",
        "body": "shadow1DLod(${1:sampler}, ${2:coord}, ${2:lod})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow2DLod(sampler2DShadow sampler, vec3 coord, float lod)": {
        "prefix": "shadow2DLod",
        "body": "shadow2DLod(${1:sampler}, ${2:coord}, ${2:lod})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow1DProjLod(sampler1DShadow sampler, vec4 coord, float lod)": {
        "prefix": "shadow1DProjLod",
        "body": "shadow1DProjLod(${1:sampler}, ${2:coord}, ${2:lod})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    "vec4 shadow2DProjLod(sampler2DShadow sampler, vec4 coord, float lod)": {
        "prefix": "shadow2DProjLod",
        "body": "shadow2DProjLod(${1:sampler}, ${2:coord}, ${2:lod})$0",
        "description": "Same functionality as the “texture” based names above with the same signature"
    },
    // 8.10. Atomic Counter Functions
    "uint atomicCounterIncrement(atomic_uint c)": {
        "prefix": "atomicCounterIncrement",
        "body": "atomicCounterIncrement(${1:c})$0",
        "description": "Atomically 1. increments the counter for c, and 2. returns its value prior to the increment operation. These two steps are done atomically with respect to the atomic counter functions in this table"
    },
    "uint atomicCounterDecrement(atomic_uint c)": {
        "prefix": "atomicCounterDecrement",
        "body": "atomicCounterDecrement(${1:c})$0",
        "description": "Atomically 1. decrements the counter for c, and 2. returns the value resulting from the decrement operation. These two steps are done atomically with respect to the atomic counter functions in this table"
    },
    "uint atomicCounter(atomic_uint c)": {
        "prefix": "atomicCounter",
        "body": "atomicCounter(${1:c})$0",
        "description": "Returns the counter value for c"
    },
    "uint atomicCounterAdd(atomic_uint c, uint data)": {
        "prefix": "atomicCounterAdd",
        "body": "atomicCounterAdd(${1:c}, ${2:data})$0",
        "description": "Atomically 1. adds the value of data to the counter for c, and 2. returns its value prior to the operation. These two steps are done atomically with respect to the atomic counter functions in this table"
    },
    "uint atomicCounterSubtract(atomic_uint c, uint data)": {
        "prefix": "atomicCounterSubtract",
        "body": "atomicCounterSubtract(${1:c}, ${2:data})$0",
        "description": "Atomically 1. subtracts the value of data from the counter for c, and 2. returns its value prior to the operation. These two steps are done atomically with respect to the atomic counter functions in this table"
    },
    "uint atomicCounterMin(atomic_uint c, uint data)": {
        "prefix": "atomicCounterMin",
        "body": "atomicCounterMin(${1:c}, ${2:data})$0",
        "description": "Atomically 1. sets the counter for c to the minimum of the value of the counter and the value of data, and 2. returns the value prior to the operation. These two steps are done atomically with respect to the atomic counter functions in this table"
    },
    "uint atomicCounterMax(atomic_uint c, uint data)": {
        "prefix": "atomicCounterMax",
        "body": "atomicCounterMax(${1:c}, ${2:data})$0",
        "description": "Atomically 1. sets the counter for c to the maximum of the value of the counter and the value of data, and 2. returns the value prior to the operation. These two steps are done atomically with respect to the atomic counter functions in this table"
    },
    "uint atomicCounterAnd(atomic_uint c, uint data)": {
        "prefix": "atomicCounterAnd",
        "body": "atomicCounterAnd(${1:c}, ${2:data})$0",
        "description": "Atomically 1. sets the counter for c to the bitwise AND of the value of the counter and the value of data, and 2. returns the value prior to the operation. These two steps are done atomically with respect to the atomic counter functions in this table"
    },
    "uint atomicCounterOr(atomic_uint c, uint data)": {
        "prefix": "atomicCounterOr",
        "body": "atomicCounterOr(${1:c}, ${2:data})$0",
        "description": "Atomically 1. sets the counter for c to the bitwise OR of the value of the counter and the value of data, and 2. returns the value prior to the operation. These two steps are done atomically with respect to the atomic counter functions in this table"
    },
    "uint atomicCounterXor(atomic_uint c, uint data)": {
        "prefix": "atomicCounterXor",
        "body": "atomicCounterXor(${1:c}, ${2:data})$0",
        "description": "Atomically 1. sets the counter for c to the bitwise XOR of the value of the counter and the value of data, and 2. returns the value prior to the operation. These two steps are done atomically with respect to the atomic counter functions in this table"
    },
    "uint atomicCounterExchange(atomic_uint c, uint data)": {
        "prefix": "atomicCounterExchange",
        "body": "atomicCounterExchange(${1:c}, ${2:data})$0",
        "description": "Atomically 1. sets the counter value for c to the value of data, and 2. returns its value prior to the operation. These two steps are done atomically with respect to the atomic counter functions in this table"
    },
    "uint atomicCounterCompSwap(atomic_uint c, uint compare, uint data)": {
        "prefix": "atomicCounterCompSwap",
        "body": "atomicCounterCompSwap(${1:c}, ${2:data})$0",
        "description": "Atomically 1. compares the value of compare and the counter value for c 2. if the values are equal, sets the counter value for c to the value of data, and 3. returns its value prior to the operation. These three steps are done atomically with respect to the atomic counter functions in this table"
    },
    // 8.11. Atomic Memory Functions
    "uint atomicAdd(inout uint mem, uint data)": {
        "prefix": "atomicAdd",
        "body": "atomicAdd(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by adding the value of data to the contents mem"
    },
    "int atomicAdd(inout int mem, int data)": {
        "prefix": "atomicAdd",
        "body": "atomicAdd(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by adding the value of data to the contents mem"
    },
    "uint atomicMin(inout uint mem, uint data)": {
        "prefix": "atomicMin",
        "body": "atomicMin(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by taking the minimum of the value of data and the contents of mem"
    },
    "int atomicMin(inout int mem, int data)": {
        "prefix": "atomicMin",
        "body": "atomicMin(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by taking the minimum of the value of data and the contents of mem"
    },
    "uint atomicMax(inout uint mem, uint data)": {
        "prefix": "atomicMax",
        "body": "atomicMax(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by taking the maximum of the value of data and the contents of mem"
    },
    "int atomicMax(inout int mem, int data)": {
        "prefix": "atomicMax",
        "body": "atomicMax(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by taking the maximum of the value of data and the contents of mem"
    },
    "uint atomicAnd(inout uint mem, uint data)": {
        "prefix": "atomicAnd",
        "body": "atomicAnd(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise AND of the value of data and the contents of mem"
    },
    "int atomicAnd(inout int mem, int data)": {
        "prefix": "atomicAnd",
        "body": "atomicAnd(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise AND of the value of data and the contents of mem"
    },
    "uint atomicOr(inout uint mem, uint data)": {
        "prefix": "atomicOr",
        "body": "atomicOr(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise OR of the value of data and the contents of mem"
    },
    "int atomicOr(inout int mem, int data)": {
        "prefix": "atomicOr",
        "body": "atomicOr(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise OR of the value of data and the contents of mem"
    },
    "uint atomicXor(inout uint mem, uint data)": {
        "prefix": "atomicXor",
        "body": "atomicXor(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise EXCLUSIVE OR of the value of data and the contents of mem"
    },
    "int atomicXor(inout int mem, int data)": {
        "prefix": "atomicXor",
        "body": "atomicXor(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise EXCLUSIVE OR of the value of data and the contents of mem"
    },
    "uint atomicExchange(inout uint mem, uint data)": {
        "prefix": "atomicExchange",
        "body": "atomicExchange(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by simply copying the value of data"
    },
    "int atomicExchange(inout int mem, int data)": {
        "prefix": "atomicExchange",
        "body": "atomicExchange(${1:mem}, ${2:data})$0",
        "description": "Computes a new value by simply copying the value of data"
    },
    "uint atomicCompSwap(inout uint mem, uint compare, uint data)": {
        "prefix": "atomicCompSwap",
        "body": "atomicCompSwap(${1:mem}, ${2:data})$0",
        "description": "Compares the value of compare and the contents of mem. If the values are equal, the new value is given by data; otherwise, it is taken from the original contents of mem"
    },
    "int atomicCompSwap(inout int mem, int compare, int data)": {
        "prefix": "atomicCompSwap",
        "body": "atomicCompSwap(${1:mem}, ${2:data})$0",
        "description": "Compares the value of compare and the contents of mem. If the values are equal, the new value is given by data; otherwise, it is taken from the original contents of mem"
    },
    // 8.12. Image Functions
    "int imageSize(readonly writeonly gimage1D image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "ivec2 imageSize(readonly writeonly gimage2D image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "ivec3 imageSize(readonly writeonly gimage3D image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "ivec2 imageSize(readonly writeonly gimageCube image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "ivec3 imageSize(readonly writeonly gimageCubeArray image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "ivec3 imageSize(readonly writeonly gimage2DArray image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "ivec2 imageSize(readonly writeonly gimage2DRect image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "ivec2 imageSize(readonly writeonly gimage1DArray image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "ivec2 imageSize(readonly writeonly gimage2DMS image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "ivec3 imageSize(readonly writeonly gimage2DMSArray image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "int imageSize(readonly writeonly gimageBuffer image)": {
        "prefix": "imageSize",
        "body": "imageSize(${1:image})$0",
        "description": "Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed. Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory"
    },
    "int imageSamples(readonly writeonly gimage2DMS image)": {
        "prefix": "imageSamples",
        "body": "imageSamples(${1:image})$0",
        "description": "Returns the number of samples of the image or images bound to image"
    },
    "int imageSamples(readonly writeonly gimage2DMSArray image)": {
        "prefix": "imageSamples",
        "body": "imageSamples(${1:image})$0",
        "description": "Returns the number of samples of the image or images bound to image"
    },
    "gvec4 imageLoad(readonly IMAGE_PARAMS)": {
        "prefix": "imageLoad",
        "body": "imageLoad(${1:IMAGE_PARAMS})$0",
        "description": "Loads the texel at the coordinate P from the image unit image (in IMAGE_PARAMS). For multisample loads, the sample number is given by sample. When image, P, and sample identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in section 8.26 “Texture Image Loads and Stores” of the OpenGL Specification and returned"
    },
    "void imageStore(writeonly IMAGE_PARAMS, gvec4 data)": {
        "prefix": "imageLoad",
        "body": "imageLoad(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Stores data into the texel at the coordinate P from the image specified by image. For multisample stores, the sample number is given by sample. When image, P, and sample identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in section 8.26 “Texture Image Loads and Stores” of the OpenGL Specification and stored to the specified texel"
    },
    "uint imageAtomicAdd(IMAGE_PARAMS, uint data)": {
        "prefix": "imageAtomicAdd",
        "body": "imageAtomicAdd(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by adding the value of data to the contents of the selected texel"
    },
    "int imageAtomicAdd(IMAGE_PARAMS, int data)": {
        "prefix": "imageAtomicAdd",
        "body": "imageAtomicAdd(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by adding the value of data to the contents of the selected texel"
    },
    "uint imageAtomicMin(IMAGE_PARAMS, uint data)": {
        "prefix": "imageAtomicMin",
        "body": "imageAtomicMin(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by taking the minimum of the value of data and the contents of the selected texel"
    },
    "int imageAtomicMin(IMAGE_PARAMS, int data)": {
        "prefix": "imageAtomicMin",
        "body": "imageAtomicMin(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by taking the minimum of the value of data and the contents of the selected texel"
    },
    "uint imageAtomicMax(IMAGE_PARAMS, uint data)": {
        "prefix": "imageAtomicMax",
        "body": "imageAtomicMax(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by taking the maximum of the value data and the contents of the selected texel"
    },
    "int imageAtomicMax(IMAGE_PARAMS, int data)": {
        "prefix": "imageAtomicMax",
        "body": "imageAtomicMax(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by taking the maximum of the value data and the contents of the selected texel"
    },
    "uint imageAtomicAnd(IMAGE_PARAMS, uint data)": {
        "prefix": "imageAtomicAnd",
        "body": "imageAtomicAnd(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise AND of the value of data and the contents of the selected texel"
    },
    "int imageAtomicAnd(IMAGE_PARAMS, int data)": {
        "prefix": "imageAtomicAnd",
        "body": "imageAtomicAnd(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise AND of the value of data and the contents of the selected texel"
    },
    "uint imageAtomicOr(IMAGE_PARAMS, uint data)": {
        "prefix": "imageAtomicOr",
        "body": "imageAtomicOr(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise OR of the value of data and the contents of the selected texel"
    },
    "int imageAtomicOr(IMAGE_PARAMS, int data)": {
        "prefix": "imageAtomicOr",
        "body": "imageAtomicOr(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise OR of the value of data and the contents of the selected texel"
    },
    "uint imageAtomicXor(IMAGE_PARAMS, uint data)": {
        "prefix": "imageAtomicXor",
        "body": "imageAtomicXor(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise EXCLUSIVE OR of the value of data and the contents of the selected texel"
    },
    "int imageAtomicXor(IMAGE_PARAMS, int data)": {
        "prefix": "imageAtomicXor",
        "body": "imageAtomicXor(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by performing a bit-wise EXCLUSIVE OR of the value of data and the contents of the selected texel"
    },
    "uint imageAtomicExchange(IMAGE_PARAMS, uint data)": {
        "prefix": "imageAtomicExchange",
        "body": "imageAtomicExchange(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by simply copying the value of data"
    },
    "int imageAtomicExchange(IMAGE_PARAMS, int data)": {
        "prefix": "imageAtomicExchange",
        "body": "imageAtomicExchange(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by simply copying the value of data"
    },
    "float imageAtomicExchange(IMAGE_PARAMS, float data)": {
        "prefix": "imageAtomicExchange",
        "body": "imageAtomicExchange(${1:IMAGE_PARAMS}, ${2:data})$0",
        "description": "Computes a new value by simply copying the value of data"
    },
    "uint imageAtomicCompSwap(IMAGE_PARAMS, uint compare, uint data)": {
        "prefix": "imageAtomicCompSwap",
        "body": "imageAtomicCompSwap(${1:IMAGE_PARAMS}, ${2:compare}, ${3:data})$0",
        "description": "Compares the value of compare and the contents of the selected texel. If the values are equal, the new value is given by data; otherwise, it is taken from the original value loaded from the texel"
    },
    "int imageAtomicCompSwap(IMAGE_PARAMS, int compare, int data)": {
        "prefix": "imageAtomicCompSwap",
        "body": "imageAtomicCompSwap(${1:IMAGE_PARAMS}, ${2:compare}, ${3:data})$0",
        "description": "Compares the value of compare and the contents of the selected texel. If the values are equal, the new value is given by data; otherwise, it is taken from the original value loaded from the texel"
    },
    // 8.13. Geometry Shader Functions
    "void EmitStreamVertex(int stream)": {
        "prefix": "EmitStreamVertex",
        "body": "EmitStreamVertex(${1:stream})$0",
        "description": "Emits the current values of output variables to the current output primitive on stream stream. The argument to stream must be a constant integral expression. On return from this call, the values of all output variables are undefined. Can only be used if multiple output streams are supported"
    },
    "void EndStreamPrimitive(int stream)": {
        "prefix": "EndStreamPrimitive",
        "body": "EndStreamPrimitive(${1:stream})$0",
        "description": "Completes the current output primitive on stream stream and starts a new one. The argument to stream must be a constant integral expression. No vertex is emitted. Can only be used if multiple output streams are supported"
    },
    "void EmitVertex()": {
        "prefix": "EmitVertex",
        "body": "EmitVertex()$0",
        "description": "Emits the current values of output variables to the current output primitive. When multiple output streams are supported, this is equivalent to calling EmitStreamVertex(0). On return from this call, the values of output variables are undefined"
    },
    "void EndPrimitive()": {
        "prefix": "EndPrimitive",
        "body": "EndPrimitive()$0",
        "description": "Completes the current output primitive and starts a new one. When multiple output streams are supported, this is equivalent to calling EndStreamPrimitive(0). No vertex is emitted"
    },
    // 8.14. Fragment Processing Functions
    "genFType dFdx(genFType p)": {
        "prefix": "dFdx",
        "body": "dFdx(${1:p})$0",
        "description": "Returns either dFdxFine(p) or dFdxCoarse(p), based on implementation choice, presumably whichever is the faster, or by whichever is selected in the API through quality-versus-speed hints."
    },
    "genFType dFdy(genFType p)": {
        "prefix": "dFdy",
        "body": "dFdy(${1:p})$0",
        "description": "Returns either dFdyFine(p) or dFdyCoarse(p), based on implementation choice, presumably whichever is the faster, or by whichever is selected in the API through quality-versus-speed hints."
    },
    "genFType dFdxFine(genFType p)": {
        "prefix": "dFdxFine",
        "body": "dFdxFine(${1:p})$0",
        "description": "Returns the partial derivative of p with respect to the window x coordinate. Will use local differencing based on the value of p for the current fragment and its immediate neighbor(s)."
    },
    "genFType dFdyFine(genFType p)": {
        "prefix": "genFType",
        "body": "genFType(${1:p})$0",
        "description": "Returns the partial derivative of p with respect to the window y coordinate. Will use local differencing based on the value of p for the current fragment and its immediate neighbor(s)."
    },
    "genFType dFdxCoarse(genFType p)": {
        "prefix": "dFdxCoarse",
        "body": "dFdxCoarse(${1:p})$0",
        "description": "Returns the partial derivative of p with respect to the window x coordinate. Will use local differencing based on the value of p for the current fragment’s neighbors, and will possibly, but not necessarily, include the value of p for the current fragment. That is, over a given area, the implementation can x compute derivatives in fewer unique locations than would be allowed for dFdxFine(p)"
    },
    "genFType dFdyCoarse(genFType p)": {
        "prefix": "dFdyCoarse",
        "body": "dFdyCoarse(${1:p})$0",
        "description": "Returns the partial derivative of p with respect to the window y coordinate. Will use local differencing based on the value of p for the current fragment’s neighbors, and will possibly, but not necessarily, include the value of p for the current fragment. That is, over a given area, the implementation can compute y derivatives in fewer unique locations than would be allowed for dFdyFine(p)"
    },
    "genFType fwidth(genFType p)": {
        "prefix": "fwidth",
        "body": "fwidth(${1:p})$0",
        "description": "Returns abs(dFdx(p)) + abs(dFdy(p))"
    },
    "genFType fwidthFine(genFType p)": {
        "prefix": "fwidthFine",
        "body": "fwidthFine(${1:p})$0",
        "description": "Returns abs(dFdxFine(p)) + abs(dFdyFine(p))"
    },
    "genFType fwidthCoarse(genFType p)": {
        "prefix": "fwidthCoarse",
        "body": "fwidthCoarse(${1:p})$0",
        "description": "Returns abs(dFdxCoarse(p)) + abs(dFdyCoarse(p))"
    },
    "float interpolateAtCentroid(float interpolant)": {
        "prefix": "interpolateAtCentroid",
        "body": "interpolateAtCentroid(${1:interpolant})$0",
        "description": "Returns the value of the input interpolant sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the same value assigned to the input variable if declared with the centroid qualifier"
    },
    "vec2 interpolateAtCentroid(vec2 interpolant)": {
        "prefix": "interpolateAtCentroid",
        "body": "interpolateAtCentroid(${1:interpolant})$0",
        "description": "Returns the value of the input interpolant sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the same value assigned to the input variable if declared with the centroid qualifier"
    },
    "vec3 interpolateAtCentroid(vec3 interpolant)": {
        "prefix": "interpolateAtCentroid",
        "body": "interpolateAtCentroid(${1:interpolant})$0",
        "description": "Returns the value of the input interpolant sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the same value assigned to the input variable if declared with the centroid qualifier"
    },
    "vec4 interpolateAtCentroid(vec4 interpolant)": {
        "prefix": "interpolateAtCentroid",
        "body": "interpolateAtCentroid(${1:interpolant})$0",
        "description": "Returns the value of the input interpolant sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the same value assigned to the input variable if declared with the centroid qualifier"
    },
    "float interpolateAtSample(float interpolant, int sample)": {
        "prefix": "interpolateAtSample",
        "body": "interpolateAtSample(${1:interpolant}, ${2:sample})$0",
        "description": "Returns the value of the input interpolant variable at the location of sample number sample. If multisample buffers are not available, the input variable will be evaluated at the center of the pixel. If sample sample does not exist, the position used to interpolate the input variable is undefined"
    },
    "vec2 interpolateAtSample(vec2 interpolant, int sample)": {
        "prefix": "interpolateAtSample",
        "body": "interpolateAtSample(${1:interpolant}, ${2:sample})$0",
        "description": "Returns the value of the input interpolant variable at the location of sample number sample. If multisample buffers are not available, the input variable will be evaluated at the center of the pixel. If sample sample does not exist, the position used to interpolate the input variable is undefined"
    },
    "vec3 interpolateAtSample(vec3 interpolant, int sample)": {
        "prefix": "interpolateAtSample",
        "body": "interpolateAtSample(${1:interpolant}, ${2:sample})$0",
        "description": "Returns the value of the input interpolant variable at the location of sample number sample. If multisample buffers are not available, the input variable will be evaluated at the center of the pixel. If sample sample does not exist, the position used to interpolate the input variable is undefined"
    },
    "vec4 interpolateAtSample(vec4 interpolant, int sample)": {
        "prefix": "interpolateAtSample",
        "body": "interpolateAtSample(${1:interpolant}, ${2:sample})$0",
        "description": "Returns the value of the input interpolant variable at the location of sample number sample. If multisample buffers are not available, the input variable will be evaluated at the center of the pixel. If sample sample does not exist, the position used to interpolate the input variable is undefined"
    },
    "float interpolateAtOffset(float interpolant, vec2 offset)": {
        "prefix": "interpolateAtOffset",
        "body": "interpolateAtOffset(${1:interpolant}, ${2:offset})$0",
        "description": "Returns the value of the input interpolant variable sampled at an offset from the center of the pixel specified by offset. The two floating- point components of offset, give the offset in pixels in the x and y directions, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation- dependent"
    },
    "vec2 interpolateAtOffset(vec2 interpolant, vec2 offset)": {
        "prefix": "interpolateAtOffset",
        "body": "interpolateAtOffset(${1:interpolant}, ${2:offset})$0",
        "description": "Returns the value of the input interpolant variable sampled at an offset from the center of the pixel specified by offset. The two floating- point components of offset, give the offset in pixels in the x and y directions, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation- dependent"
    },
    "vec3 interpolateAtOffset(vec3 interpolant, vec2 offset)": {
        "prefix": "interpolateAtOffset",
        "body": "interpolateAtOffset(${1:interpolant}, ${2:offset})$0",
        "description": "Returns the value of the input interpolant variable sampled at an offset from the center of the pixel specified by offset. The two floating- point components of offset, give the offset in pixels in the x and y directions, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation- dependent"
    },
    "vec4 interpolateAtOffset(vec4 interpolant, vec2 offset)": {
        "prefix": "interpolateAtOffset",
        "body": "interpolateAtOffset(${1:interpolant}, ${2:offset})$0",
        "description": "Returns the value of the input interpolant variable sampled at an offset from the center of the pixel specified by offset. The two floating- point components of offset, give the offset in pixels in the x and y directions, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation- dependent"
    },
    // 8.15. Noise Functions
    "float noise1(genFType x)": {
        "prefix": "noise1",
        "body": "noise1(${1:x})$0",
        "description": "Returns a 1D noise value based on the input value x"
    },
    "vec2 noise2(genFType x)": {
        "prefix": "noise2",
        "body": "noise2(${1:x})$0",
        "description": "Returns a 2D noise value based on the input value x"
    },
    "vec3 noise3(genFType x)": {
        "prefix": "noise3",
        "body": "noise3(${1:x})$0",
        "description": "Returns a 3D noise value based on the input value x"
    },
    "vec4 noise4(genFType x)": {
        "prefix": "noise4",
        "body": "noise4(${1:x})$0",
        "description": "Returns a 4D noise value based on the input value x"
    },
    // 8.16. Shader Invocation Control Functions
    "void barrier()": {
        "prefix": "barrier",
        "body": "barrier()$0",
        "description": "For any given static instance of barrier(), all tessellation control shader invocations for a single input patch must enter it before any will be allowed to continue beyond it, or all compute shader invocations for a single workgroup must enter it before any will continue beyond it"
    },
    // 8.17. Shader Memory Control Functions
    "void memoryBarrier()": {
        "prefix": "memoryBarrier",
        "body": "memoryBarrier()$0",
        "description": "Control the ordering of memory transactions issued by a single shader invocation"
    },
    "void memoryBarrierAtomicCounter()": {
        "prefix": "memoryBarrierAtomicCounter",
        "body": "memoryBarrierAtomicCounter()$0",
        "description": "Control the ordering of accesses to atomic-counter variables issued by a single shader invocation"
    },
    "void memoryBarrierBuffer()": {
        "prefix": "memoryBarrierBuffer",
        "body": "memoryBarrierBuffer()$0",
        "description": "Control the ordering of memory transactions to buffer variables issued within a single shader invocation"
    },
    "void memoryBarrierShared()": {
        "prefix": "memoryBarrierShared",
        "body": "memoryBarrierShared()$0",
        "description": "Control the ordering of memory transactions to shared variables issued within a single shader invocation, as viewed by other invocations in the same workgroup. Only available in compute shaders"
    },
    "void memoryBarrierImage()": {
        "prefix": "memoryBarrierImage",
        "body": "memoryBarrierImage()$0",
        "description": "Control the ordering of memory transactions to images issued within a single shader invocation"
    },
    "void groupMemoryBarrier()": {
        "prefix": "groupMemoryBarrier",
        "body": "groupMemoryBarrier()$0",
        "description": "Control the ordering of all memory transactions issued within a single shader invocation, as viewed by other invocations in the same workgroup. Only available in compute shaders"
    },
    // 8.18. Subpass-Input Functions
    "gvec4 subpassLoad(gsubpassInput subpass)": {
        "prefix": "subpassLoad",
        "body": "subpassLoad(${1:subpass})$0",
        "description": "Read from a subpass input, from the implicit location (x, y, layer) of the current fragment coordinate"
    },
    "gvec4 subpassLoad(gsubpassInputMS subpass, int sample)": {
        "prefix": "subpassLoad",
        "body": "subpassLoad(${1:subpass}, ${2:sample})$0",
        "description": "Read from a subpass input, from the implicit location (x, y, layer) of the current fragment coordinate"
    },
    // 8.19. Shader Invocation Group Functions
    "bool anyInvocation(bool value)": {
        "prefix": "anyInvocation",
        "body": "anyInvocation(${1:value})$0",
        "description": "Returns true if and only if value is true for at least one active invocation in the group"
    },
    "bool allInvocations(bool value)": {
        "prefix": "allInvocations",
        "body": "allInvocations(${1:value})$0",
        "description": "Returns true if and only if value is true for all active invocations in the group"
    },
    "bool allInvocationsEqual(bool value)": {
        "prefix": "allInvocationsEqual",
        "body": "allInvocationsEqual(${1:value})$0",
        "description": "Returns true if value is the same for all active invocations in the group"
    }
}